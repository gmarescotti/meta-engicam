/**
 * This file was generated by:
 * "C:\Python39\Scripts\cantools generate_qt_source ..\fincantieri-app-fc02-1.2\modbus.dbc --signals all --bit-fields --no-strict --no-size-and-memset"
 * version 36.4.12 Tue Aug  2 15:22:19 2022.
 */

#ifndef MODBUS_QT_H
#define MODBUS_QT_H

#include <QObject>
#include <QVariant>
#include <QByteArray>

#include <QModbusDataUnit>
#include "modbus.h"
#include <QDebug>
#include <QLoggingCategory>

#include <QTimer>
#include <QDateTime>

#include "myabstractitemmodel.h"

class modbusQtSignals;
class modbusQtMessage;

Q_DECLARE_LOGGING_CATEGORY(rgm_cantools_modbus)

/*
 * Class declaration to declare a single signal exported
 * to Qt environment.
 */
class QVariantSignalmodbus : public QObject
{
    Q_OBJECT

    Q_PROPERTY(QVariant val WRITE send MEMBER m_val NOTIFY changed)
    Q_PROPERTY(QVariant silent_val WRITE silent_send MEMBER m_val)
    Q_PROPERTY(QVariant smart_val WRITE smart_send MEMBER m_val NOTIFY changed)
    Q_PROPERTY(QVariant max MEMBER m_max CONSTANT)
    Q_PROPERTY(QVariant min MEMBER m_min CONSTANT)
    Q_PROPERTY(QVariant precision MEMBER m_precision CONSTANT)
    Q_PROPERTY(QString unit MEMBER m_unit CONSTANT)
    Q_PROPERTY(QString name MEMBER m_name CONSTANT)
    Q_PROPERTY(QString description MEMBER m_description CONSTANT)

    Q_PROPERTY(modbusQtMessage* message MEMBER parent CONSTANT)

signals:
    void changed(QDateTime t);

public:
    QVariantSignalmodbus(modbusQtMessage *parent, QVariant max, QVariant min, QVariant precision, QString unit, QString name, QString description) :
        parent(parent), m_val(QVariant()), m_max(max), m_min(min), m_precision(precision), m_unit(unit), m_name(name), m_description(description) {}

    modbusQtMessage *parent;
    QVariant m_val;
    const QVariant m_max, m_min, m_precision;
    const QString m_unit, m_name, m_description;

protected:
    virtual void send(QVariant x, int option=0) = 0;
    void silent_send(QVariant x) {
        this->send(x, 1);
    }
    void smart_send(QVariant x) {
        this->send(x, 2);
    }
};

/**
 * Class declaration to declare all signals exported
 * to Qt environment.
 */
class modbusQtMessage : public QObject
{
    Q_OBJECT

    Q_PROPERTY(bool valid MEMBER m_valid NOTIFY on_valid)
    Q_PROPERTY(uint frameId MEMBER m_frameId CONSTANT)
    Q_PROPERTY(bool is_extended MEMBER is_extended CONSTANT)
    Q_PROPERTY(uint length MEMBER m_length CONSTANT)
    Q_PROPERTY(uint cycle_time MEMBER m_cycle_time CONSTANT)
    Q_PROPERTY(bool owner READ get_owner WRITE set_owner)
    Q_PROPERTY(uint stationAddress MEMBER m_stationAddress CONSTANT)

public slots:
    virtual void set_owner(bool) {}
    virtual bool get_owner() {return true;}
    void update();

signals:
    void on_valid(QDateTime t);

public:
    modbusQtMessage(uint stationAddress, uint frameId, bool is_extended, uint length, uint cycle_time) : 
        m_stationAddress(stationAddress), m_frameId(frameId), m_length(length), is_extended(is_extended), m_cycle_time(cycle_time), m_valid(false) {}

public:
    const uint m_stationAddress;
    const uint m_frameId;
    const uint m_length;
    const bool is_extended;
    const uint m_cycle_time;
    qint64 m_timestamp;
    bool m_valid;

public:

    virtual void send_frame() = 0;
    virtual void received(const QModbusDataUnit &frame) = 0;
    
    void check_exipiration_timestamp(qint64 now) {
        qCDebug(rgm_cantools_modbus) << "check_exipiration_timestamp: " << m_cycle_time << " > " << now << "-" << m_timestamp << "=" << now - m_timestamp;
        if ((m_cycle_time > 0) && (now - m_timestamp > (m_cycle_time * 15))) {
            if (m_valid) {
                m_valid = false;
                emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
        }
    }
};

/*
 * Class declaration to manage all persistent signals exported
 * to Qt environment.
 */
class QVariantHistorySignalmodbus: public QVariantSignalmodbus {

    Q_OBJECT

private slots:
    void update(QDateTime t);
    void update_valid(QDateTime t);

public:
    QVariantHistorySignalmodbus(modbusQtMessage *p, QVariant max, QVariant min, QVariant precision, QString unit, QString name, QString description) :
        QVariantSignalmodbus(p, max, min, precision, unit, name, description) {
        QObject::connect(this, &QVariantHistorySignalmodbus::changed, this, &QVariantHistorySignalmodbus::update);
        QObject::connect(this->parent, &modbusQtMessage::on_valid, this, &QVariantHistorySignalmodbus::update_valid);
    }

    QList<QPair<QDateTime, QVariant>> m_data;
};


    class QVariantSignal_dcdc_warning_word_2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_power_current_reference : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_estimated_time_to_power : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_max_available_current : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_power_current_min_handling : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_extended_info2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_error_word_3 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_dcdc_current : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_max : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dc_bus_voltage : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_warning_word_1 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fcstack_voltage : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_warning_word_3 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_status_freeze_protection : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_pwr_unit_temperature : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fcstack_current : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_system_off_request : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_status : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_pos_mix_valve2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_error_word_1 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_tcm_hs_pri_out2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_event_code2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_reset2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fcstack_status : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fast_shutdown_request : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_tcm_hs_sec_in_sp2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dc_bus_current : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_sp : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_estimated_time_for_shutdown : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_opt : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_error_word_2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_dcdc_running : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_mute_h2_sens_exhaust2 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_power_current_mode : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_freeze_protection_request : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_dcdc_power : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_act : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_voltage : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_min : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_status_word_1 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_max_state : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_max_available_fc_current : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_power_peripheral : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_dcdc_power_limitation : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_extended_info1 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_dcdc_failure : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_fc_event_code1 : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

    class QVariantSignal_dcdc_max_available_power : public QVariantSignalmodbus {
        using QVariantSignalmodbus::QVariantSignalmodbus;
        void send(QVariant x, int option);
    };
    

/**
 * Class declaration to declare all signals exported
 * to Qt environment.
 */
class modbusQtMessages;
class modbusQtSignals : public QObject
{
    Q_OBJECT

    Q_PROPERTY(modbusQtMessages* messages MEMBER m_messages CONSTANT)

    Q_PROPERTY(QVariantSignalmodbus* dcdc_warning_word_2 MEMBER m_dcdc_warning_word_2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* power_current_reference MEMBER m_power_current_reference CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* estimated_time_to_power MEMBER m_estimated_time_to_power CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_max_available_current MEMBER m_dcdc_max_available_current CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* power_current_min_handling MEMBER m_power_current_min_handling CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_extended_info2 MEMBER m_fc_extended_info2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_error_word_3 MEMBER m_dcdc_error_word_3 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_dcdc_current MEMBER m_fc_dcdc_current CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_max MEMBER m_fc_power_max CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dc_bus_voltage MEMBER m_dc_bus_voltage CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_warning_word_1 MEMBER m_dcdc_warning_word_1 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fcstack_voltage MEMBER m_fcstack_voltage CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_warning_word_3 MEMBER m_dcdc_warning_word_3 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* status_freeze_protection MEMBER m_status_freeze_protection CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_pwr_unit_temperature MEMBER m_dcdc_pwr_unit_temperature CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fcstack_current MEMBER m_fcstack_current CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* system_off_request MEMBER m_system_off_request CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_status MEMBER m_dcdc_status CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* pos_mix_valve2 MEMBER m_pos_mix_valve2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_error_word_1 MEMBER m_dcdc_error_word_1 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* tcm_hs_pri_out2 MEMBER m_tcm_hs_pri_out2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_event_code2 MEMBER m_fc_event_code2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_reset2 MEMBER m_dcdc_reset2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fcstack_status MEMBER m_fcstack_status CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fast_shutdown_request MEMBER m_fast_shutdown_request CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* tcm_hs_sec_in_sp2 MEMBER m_tcm_hs_sec_in_sp2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dc_bus_current MEMBER m_dc_bus_current CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_sp MEMBER m_fc_power_sp CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* estimated_time_for_shutdown MEMBER m_estimated_time_for_shutdown CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_opt MEMBER m_fc_power_opt CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_error_word_2 MEMBER m_dcdc_error_word_2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_dcdc_running MEMBER m_fc_dcdc_running CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* mute_h2_sens_exhaust2 MEMBER m_mute_h2_sens_exhaust2 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* power_current_mode MEMBER m_power_current_mode CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* freeze_protection_request MEMBER m_freeze_protection_request CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_dcdc_power MEMBER m_fc_dcdc_power CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_act MEMBER m_fc_power_act CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_voltage MEMBER m_dcdc_voltage CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_min MEMBER m_fc_power_min CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_status_word_1 MEMBER m_dcdc_status_word_1 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_max_state MEMBER m_fc_power_max_state CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_max_available_fc_current MEMBER m_dcdc_max_available_fc_current CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_power_peripheral MEMBER m_fc_power_peripheral CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_dcdc_power_limitation MEMBER m_fc_dcdc_power_limitation CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_extended_info1 MEMBER m_fc_extended_info1 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_dcdc_failure MEMBER m_fc_dcdc_failure CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* fc_event_code1 MEMBER m_fc_event_code1 CONSTANT)
    Q_PROPERTY(QVariantSignalmodbus* dcdc_max_available_power MEMBER m_dcdc_max_available_power CONSTANT)

private:
    modbusQtSignals(QObject * = nullptr);

public:
    static modbusQtSignals& instance() {
        static modbusQtSignals * _instance = nullptr;
        if ( _instance == nullptr ) {
            _instance = new modbusQtSignals();
        }
        return *_instance;
    }

    modbusQtMessages *m_messages;

    QVariantSignal_dcdc_warning_word_2 *m_dcdc_warning_word_2;
    QVariantSignal_power_current_reference *m_power_current_reference;
    QVariantSignal_estimated_time_to_power *m_estimated_time_to_power;
    QVariantSignal_dcdc_max_available_current *m_dcdc_max_available_current;
    QVariantSignal_power_current_min_handling *m_power_current_min_handling;
    QVariantSignal_fc_extended_info2 *m_fc_extended_info2;
    QVariantSignal_dcdc_error_word_3 *m_dcdc_error_word_3;
    QVariantSignal_fc_dcdc_current *m_fc_dcdc_current;
    QVariantSignal_fc_power_max *m_fc_power_max;
    QVariantSignal_dc_bus_voltage *m_dc_bus_voltage;
    QVariantSignal_dcdc_warning_word_1 *m_dcdc_warning_word_1;
    QVariantSignal_fcstack_voltage *m_fcstack_voltage;
    QVariantSignal_dcdc_warning_word_3 *m_dcdc_warning_word_3;
    QVariantSignal_status_freeze_protection *m_status_freeze_protection;
    QVariantSignal_dcdc_pwr_unit_temperature *m_dcdc_pwr_unit_temperature;
    QVariantSignal_fcstack_current *m_fcstack_current;
    QVariantSignal_system_off_request *m_system_off_request;
    QVariantSignal_dcdc_status *m_dcdc_status;
    QVariantSignal_pos_mix_valve2 *m_pos_mix_valve2;
    QVariantSignal_dcdc_error_word_1 *m_dcdc_error_word_1;
    QVariantSignal_tcm_hs_pri_out2 *m_tcm_hs_pri_out2;
    QVariantSignal_fc_event_code2 *m_fc_event_code2;
    QVariantSignal_dcdc_reset2 *m_dcdc_reset2;
    QVariantSignal_fcstack_status *m_fcstack_status;
    QVariantSignal_fast_shutdown_request *m_fast_shutdown_request;
    QVariantSignal_tcm_hs_sec_in_sp2 *m_tcm_hs_sec_in_sp2;
    QVariantSignal_dc_bus_current *m_dc_bus_current;
    QVariantSignal_fc_power_sp *m_fc_power_sp;
    QVariantSignal_estimated_time_for_shutdown *m_estimated_time_for_shutdown;
    QVariantSignal_fc_power_opt *m_fc_power_opt;
    QVariantSignal_dcdc_error_word_2 *m_dcdc_error_word_2;
    QVariantSignal_fc_dcdc_running *m_fc_dcdc_running;
    QVariantSignal_mute_h2_sens_exhaust2 *m_mute_h2_sens_exhaust2;
    QVariantSignal_power_current_mode *m_power_current_mode;
    QVariantSignal_freeze_protection_request *m_freeze_protection_request;
    QVariantSignal_fc_dcdc_power *m_fc_dcdc_power;
    QVariantSignal_fc_power_act *m_fc_power_act;
    QVariantSignal_dcdc_voltage *m_dcdc_voltage;
    QVariantSignal_fc_power_min *m_fc_power_min;
    QVariantSignal_dcdc_status_word_1 *m_dcdc_status_word_1;
    QVariantSignal_fc_power_max_state *m_fc_power_max_state;
    QVariantSignal_dcdc_max_available_fc_current *m_dcdc_max_available_fc_current;
    QVariantSignal_fc_power_peripheral *m_fc_power_peripheral;
    QVariantSignal_fc_dcdc_power_limitation *m_fc_dcdc_power_limitation;
    QVariantSignal_fc_extended_info1 *m_fc_extended_info1;
    QVariantSignal_fc_dcdc_failure *m_fc_dcdc_failure;
    QVariantSignal_fc_event_code1 *m_fc_event_code1;
    QVariantSignal_dcdc_max_available_power *m_dcdc_max_available_power;

};

class modbusQtMessage_dc_bus_current : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dc_bus_current_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dc_bus_current;
        if ((false) || (modbus.m_dc_bus_current->m_val != x)) {
            modbus.m_dc_bus_current->m_val = x;
            if (!false) {
                emit modbus.m_dc_bus_current->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dc_bus_current=" << modbus.m_dc_bus_current->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dc_bus_current_t store={};
    const QString m_name = "dc_bus_current";
};

class modbusQtMessage_fc_power_max_state : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_max_state_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_max_state;
        if ((false) || (modbus.m_fc_power_max_state->m_val != x)) {
            modbus.m_fc_power_max_state->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_max_state->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_max_state=" << modbus.m_fc_power_max_state->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_max_state_t store={};
    const QString m_name = "fc_power_max_state";
};

class modbusQtMessage_fc_power_sp : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_sp_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_sp;
        if ((false) || (modbus.m_fc_power_sp->m_val != x)) {
            modbus.m_fc_power_sp->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_sp->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_sp=" << modbus.m_fc_power_sp->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_sp_t store={};
    const QString m_name = "fc_power_sp";
};

class modbusQtMessage_dcdc_max_available_power : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_max_available_power_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_max_available_power;
        if ((false) || (modbus.m_dcdc_max_available_power->m_val != x)) {
            modbus.m_dcdc_max_available_power->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_max_available_power->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_max_available_power=" << modbus.m_dcdc_max_available_power->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_max_available_power_t store={};
    const QString m_name = "dcdc_max_available_power";
};

class modbusQtMessage_msg_40204 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_msg_40204_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.system_off_request;
        if ((false) || (modbus.m_system_off_request->m_val != x)) {
            modbus.m_system_off_request->m_val = x;
            if (!false) {
                emit modbus.m_system_off_request->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_system_off_request=" << modbus.m_system_off_request->m_val;
        }

        x = store.fast_shutdown_request;
        if ((false) || (modbus.m_fast_shutdown_request->m_val != x)) {
            modbus.m_fast_shutdown_request->m_val = x;
            if (!false) {
                emit modbus.m_fast_shutdown_request->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fast_shutdown_request=" << modbus.m_fast_shutdown_request->m_val;
        }

        x = store.freeze_protection_request;
        if ((false) || (modbus.m_freeze_protection_request->m_val != x)) {
            modbus.m_freeze_protection_request->m_val = x;
            if (!false) {
                emit modbus.m_freeze_protection_request->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_freeze_protection_request=" << modbus.m_freeze_protection_request->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_msg_40204_t store={};
    const QString m_name = "msg_40204";
};

class modbusQtMessage_msg_30201 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_msg_30201_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.status_freeze_protection;
        if ((false) || (modbus.m_status_freeze_protection->m_val != x)) {
            modbus.m_status_freeze_protection->m_val = x;
            if (!false) {
                emit modbus.m_status_freeze_protection->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_status_freeze_protection=" << modbus.m_status_freeze_protection->m_val;
        }

        x = store.mute_h2_sens_exhaust2;
        if ((false) || (modbus.m_mute_h2_sens_exhaust2->m_val != x)) {
            modbus.m_mute_h2_sens_exhaust2->m_val = x;
            if (!false) {
                emit modbus.m_mute_h2_sens_exhaust2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_mute_h2_sens_exhaust2=" << modbus.m_mute_h2_sens_exhaust2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_msg_30201_t store={};
    const QString m_name = "msg_30201";
};

class modbusQtMessage_fc_power_min : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_min_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_min;
        if ((false) || (modbus.m_fc_power_min->m_val != x)) {
            modbus.m_fc_power_min->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_min->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_min=" << modbus.m_fc_power_min->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_min_t store={};
    const QString m_name = "fc_power_min";
};

class modbusQtMessage_pos_mix_valve : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_pos_mix_valve_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.pos_mix_valve2;
        if ((false) || (modbus.m_pos_mix_valve2->m_val != x)) {
            modbus.m_pos_mix_valve2->m_val = x;
            if (!false) {
                emit modbus.m_pos_mix_valve2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_pos_mix_valve2=" << modbus.m_pos_mix_valve2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_pos_mix_valve_t store={};
    const QString m_name = "pos_mix_valve";
};

class modbusQtMessage_fc_dcdc_status : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_dcdc_status_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_dcdc_running;
        if ((false) || (modbus.m_fc_dcdc_running->m_val != x)) {
            modbus.m_fc_dcdc_running->m_val = x;
            if (!false) {
                emit modbus.m_fc_dcdc_running->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_dcdc_running=" << modbus.m_fc_dcdc_running->m_val;
        }

        x = store.fc_dcdc_failure;
        if ((false) || (modbus.m_fc_dcdc_failure->m_val != x)) {
            modbus.m_fc_dcdc_failure->m_val = x;
            if (!false) {
                emit modbus.m_fc_dcdc_failure->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_dcdc_failure=" << modbus.m_fc_dcdc_failure->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_dcdc_status_t store={};
    const QString m_name = "fc_dcdc_status";
};

class modbusQtMessage_dcdc_warning_word_3 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_warning_word_3_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_warning_word_3;
        if ((false) || (modbus.m_dcdc_warning_word_3->m_val != x)) {
            modbus.m_dcdc_warning_word_3->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_warning_word_3->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_warning_word_3=" << modbus.m_dcdc_warning_word_3->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_warning_word_3_t store={};
    const QString m_name = "dcdc_warning_word_3";
};

class modbusQtMessage_fcstack_voltage : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fcstack_voltage_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fcstack_voltage;
        if ((false) || (modbus.m_fcstack_voltage->m_val != x)) {
            modbus.m_fcstack_voltage->m_val = x;
            if (!false) {
                emit modbus.m_fcstack_voltage->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fcstack_voltage=" << modbus.m_fcstack_voltage->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fcstack_voltage_t store={};
    const QString m_name = "fcstack_voltage";
};

class modbusQtMessage_msg_30052 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_msg_30052_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_error_word_2;
        if ((false) || (modbus.m_dcdc_error_word_2->m_val != x)) {
            modbus.m_dcdc_error_word_2->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_error_word_2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_error_word_2=" << modbus.m_dcdc_error_word_2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_msg_30052_t store={};
    const QString m_name = "msg_30052";
};

class modbusQtMessage_dcdc_pwr_unit_temperature : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_pwr_unit_temperature_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_pwr_unit_temperature;
        if ((false) || (modbus.m_dcdc_pwr_unit_temperature->m_val != x)) {
            modbus.m_dcdc_pwr_unit_temperature->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_pwr_unit_temperature->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_pwr_unit_temperature=" << modbus.m_dcdc_pwr_unit_temperature->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_pwr_unit_temperature_t store={};
    const QString m_name = "dcdc_pwr_unit_temperature";
};

class modbusQtMessage_dcdc_voltage : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_voltage_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_voltage;
        if ((false) || (modbus.m_dcdc_voltage->m_val != x)) {
            modbus.m_dcdc_voltage->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_voltage->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_voltage=" << modbus.m_dcdc_voltage->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_voltage_t store={};
    const QString m_name = "dcdc_voltage";
};

class modbusQtMessage_fc_extended_info : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_extended_info_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_extended_info1;
        if ((false) || (modbus.m_fc_extended_info1->m_val != x)) {
            modbus.m_fc_extended_info1->m_val = x;
            if (!false) {
                emit modbus.m_fc_extended_info1->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_extended_info1=" << modbus.m_fc_extended_info1->m_val;
        }

        x = store.fc_extended_info2;
        if ((false) || (modbus.m_fc_extended_info2->m_val != x)) {
            modbus.m_fc_extended_info2->m_val = x;
            if (!false) {
                emit modbus.m_fc_extended_info2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_extended_info2=" << modbus.m_fc_extended_info2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_extended_info_t store={};
    const QString m_name = "fc_extended_info";
};

class modbusQtMessage_msg_30051 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_msg_30051_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_error_word_1;
        if ((false) || (modbus.m_dcdc_error_word_1->m_val != x)) {
            modbus.m_dcdc_error_word_1->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_error_word_1->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_error_word_1=" << modbus.m_dcdc_error_word_1->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_msg_30051_t store={};
    const QString m_name = "msg_30051";
};

class modbusQtMessage_estimated_time_to_power : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_estimated_time_to_power_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.estimated_time_to_power;
        if ((false) || (modbus.m_estimated_time_to_power->m_val != x)) {
            modbus.m_estimated_time_to_power->m_val = x;
            if (!false) {
                emit modbus.m_estimated_time_to_power->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_estimated_time_to_power=" << modbus.m_estimated_time_to_power->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_estimated_time_to_power_t store={};
    const QString m_name = "estimated_time_to_power";
};

class modbusQtMessage_dcdc_command : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_command_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_reset2;
        if ((false) || (modbus.m_dcdc_reset2->m_val != x)) {
            modbus.m_dcdc_reset2->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_reset2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_reset2=" << modbus.m_dcdc_reset2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_command_t store={};
    const QString m_name = "dcdc_command";
};

class modbusQtMessage_estimated_time_for_shutdown : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_estimated_time_for_shutdown_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.estimated_time_for_shutdown;
        if ((false) || (modbus.m_estimated_time_for_shutdown->m_val != x)) {
            modbus.m_estimated_time_for_shutdown->m_val = x;
            if (!false) {
                emit modbus.m_estimated_time_for_shutdown->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_estimated_time_for_shutdown=" << modbus.m_estimated_time_for_shutdown->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_estimated_time_for_shutdown_t store={};
    const QString m_name = "estimated_time_for_shutdown";
};

class modbusQtMessage_dc_bus_voltage : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dc_bus_voltage_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dc_bus_voltage;
        if ((false) || (modbus.m_dc_bus_voltage->m_val != x)) {
            modbus.m_dc_bus_voltage->m_val = x;
            if (!false) {
                emit modbus.m_dc_bus_voltage->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dc_bus_voltage=" << modbus.m_dc_bus_voltage->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dc_bus_voltage_t store={};
    const QString m_name = "dc_bus_voltage";
};

class modbusQtMessage_tcm_hs_sec_in_sp : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_tcm_hs_sec_in_sp_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.tcm_hs_sec_in_sp2;
        if ((false) || (modbus.m_tcm_hs_sec_in_sp2->m_val != x)) {
            modbus.m_tcm_hs_sec_in_sp2->m_val = x;
            if (!false) {
                emit modbus.m_tcm_hs_sec_in_sp2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_tcm_hs_sec_in_sp2=" << modbus.m_tcm_hs_sec_in_sp2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_tcm_hs_sec_in_sp_t store={};
    const QString m_name = "tcm_hs_sec_in_sp";
};

class modbusQtMessage_power_current_mode : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_power_current_mode_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.power_current_mode;
        if ((false) || (modbus.m_power_current_mode->m_val != x)) {
            modbus.m_power_current_mode->m_val = x;
            if (!false) {
                emit modbus.m_power_current_mode->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_power_current_mode=" << modbus.m_power_current_mode->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_power_current_mode_t store={};
    const QString m_name = "power_current_mode";
};

class modbusQtMessage_fc_event_code : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_event_code_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_event_code2;
        if ((false) || (modbus.m_fc_event_code2->m_val != x)) {
            modbus.m_fc_event_code2->m_val = x;
            if (!false) {
                emit modbus.m_fc_event_code2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_event_code2=" << modbus.m_fc_event_code2->m_val;
        }

        x = store.fc_event_code1;
        if ((false) || (modbus.m_fc_event_code1->m_val != x)) {
            modbus.m_fc_event_code1->m_val = x;
            if (!false) {
                emit modbus.m_fc_event_code1->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_event_code1=" << modbus.m_fc_event_code1->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_event_code_t store={};
    const QString m_name = "fc_event_code";
};

class modbusQtMessage_fc_power_act : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_act_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_act;
        if ((false) || (modbus.m_fc_power_act->m_val != x)) {
            modbus.m_fc_power_act->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_act->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_act=" << modbus.m_fc_power_act->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_act_t store={};
    const QString m_name = "fc_power_act";
};

class modbusQtMessage_dcdc_max_available_fc_current : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_max_available_fc_current_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_max_available_fc_current;
        if ((false) || (modbus.m_dcdc_max_available_fc_current->m_val != x)) {
            modbus.m_dcdc_max_available_fc_current->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_max_available_fc_current->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_max_available_fc_current=" << modbus.m_dcdc_max_available_fc_current->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_max_available_fc_current_t store={};
    const QString m_name = "dcdc_max_available_fc_current";
};

class modbusQtMessage_power_current_min_handling : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_power_current_min_handling_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.power_current_min_handling;
        if ((false) || (modbus.m_power_current_min_handling->m_val != x)) {
            modbus.m_power_current_min_handling->m_val = x;
            if (!false) {
                emit modbus.m_power_current_min_handling->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_power_current_min_handling=" << modbus.m_power_current_min_handling->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_power_current_min_handling_t store={};
    const QString m_name = "power_current_min_handling";
};

class modbusQtMessage_dcdc_max_available_current : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_max_available_current_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_max_available_current;
        if ((false) || (modbus.m_dcdc_max_available_current->m_val != x)) {
            modbus.m_dcdc_max_available_current->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_max_available_current->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_max_available_current=" << modbus.m_dcdc_max_available_current->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_max_available_current_t store={};
    const QString m_name = "dcdc_max_available_current";
};

class modbusQtMessage_dcdc_warning_word_1 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_warning_word_1_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_warning_word_1;
        if ((false) || (modbus.m_dcdc_warning_word_1->m_val != x)) {
            modbus.m_dcdc_warning_word_1->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_warning_word_1->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_warning_word_1=" << modbus.m_dcdc_warning_word_1->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_warning_word_1_t store={};
    const QString m_name = "dcdc_warning_word_1";
};

class modbusQtMessage_dcdc_status : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_status_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_status;
        if ((false) || (modbus.m_dcdc_status->m_val != x)) {
            modbus.m_dcdc_status->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_status->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_status=" << modbus.m_dcdc_status->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_status_t store={};
    const QString m_name = "dcdc_status";
};

class modbusQtMessage_tcm_hs_pri_out : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_tcm_hs_pri_out_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.tcm_hs_pri_out2;
        if ((false) || (modbus.m_tcm_hs_pri_out2->m_val != x)) {
            modbus.m_tcm_hs_pri_out2->m_val = x;
            if (!false) {
                emit modbus.m_tcm_hs_pri_out2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_tcm_hs_pri_out2=" << modbus.m_tcm_hs_pri_out2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_tcm_hs_pri_out_t store={};
    const QString m_name = "tcm_hs_pri_out";
};

class modbusQtMessage_dcdc_warning_word_2 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_dcdc_warning_word_2_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_warning_word_2;
        if ((false) || (modbus.m_dcdc_warning_word_2->m_val != x)) {
            modbus.m_dcdc_warning_word_2->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_warning_word_2->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_warning_word_2=" << modbus.m_dcdc_warning_word_2->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_dcdc_warning_word_2_t store={};
    const QString m_name = "dcdc_warning_word_2";
};

class modbusQtMessage_fc_power_peripheral : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_peripheral_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_peripheral;
        if ((false) || (modbus.m_fc_power_peripheral->m_val != x)) {
            modbus.m_fc_power_peripheral->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_peripheral->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_peripheral=" << modbus.m_fc_power_peripheral->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_peripheral_t store={};
    const QString m_name = "fc_power_peripheral";
};

class modbusQtMessage_msg_30053 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_msg_30053_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_error_word_3;
        if ((false) || (modbus.m_dcdc_error_word_3->m_val != x)) {
            modbus.m_dcdc_error_word_3->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_error_word_3->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_error_word_3=" << modbus.m_dcdc_error_word_3->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_msg_30053_t store={};
    const QString m_name = "msg_30053";
};

class modbusQtMessage_fcstack_status : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fcstack_status_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fcstack_status;
        if ((false) || (modbus.m_fcstack_status->m_val != x)) {
            modbus.m_fcstack_status->m_val = x;
            if (!false) {
                emit modbus.m_fcstack_status->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fcstack_status=" << modbus.m_fcstack_status->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fcstack_status_t store={};
    const QString m_name = "fcstack_status";
};

class modbusQtMessage_fc_power_opt : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_opt_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_opt;
        if ((false) || (modbus.m_fc_power_opt->m_val != x)) {
            modbus.m_fc_power_opt->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_opt->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_opt=" << modbus.m_fc_power_opt->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_opt_t store={};
    const QString m_name = "fc_power_opt";
};

class modbusQtMessage_fc_dcdc_power_limitation : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_dcdc_power_limitation_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_dcdc_power_limitation;
        if ((false) || (modbus.m_fc_dcdc_power_limitation->m_val != x)) {
            modbus.m_fc_dcdc_power_limitation->m_val = x;
            if (!false) {
                emit modbus.m_fc_dcdc_power_limitation->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_dcdc_power_limitation=" << modbus.m_fc_dcdc_power_limitation->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_dcdc_power_limitation_t store={};
    const QString m_name = "fc_dcdc_power_limitation";
};

class modbusQtMessage_power_current_reference : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_power_current_reference_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.power_current_reference;
        if ((false) || (modbus.m_power_current_reference->m_val != x)) {
            modbus.m_power_current_reference->m_val = x;
            if (!false) {
                emit modbus.m_power_current_reference->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_power_current_reference=" << modbus.m_power_current_reference->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_power_current_reference_t store={};
    const QString m_name = "power_current_reference";
};

class modbusQtMessage_fc_power_max : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_power_max_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_power_max;
        if ((false) || (modbus.m_fc_power_max->m_val != x)) {
            modbus.m_fc_power_max->m_val = x;
            if (!false) {
                emit modbus.m_fc_power_max->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_power_max=" << modbus.m_fc_power_max->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_power_max_t store={};
    const QString m_name = "fc_power_max";
};

class modbusQtMessage_msg_30101 : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_msg_30101_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.dcdc_status_word_1;
        if ((false) || (modbus.m_dcdc_status_word_1->m_val != x)) {
            modbus.m_dcdc_status_word_1->m_val = x;
            if (!false) {
                emit modbus.m_dcdc_status_word_1->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_dcdc_status_word_1=" << modbus.m_dcdc_status_word_1->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_msg_30101_t store={};
    const QString m_name = "msg_30101";
};

class modbusQtMessage_fc_dcdc_power : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_dcdc_power_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_dcdc_power;
        if ((false) || (modbus.m_fc_dcdc_power->m_val != x)) {
            modbus.m_fc_dcdc_power->m_val = x;
            if (!false) {
                emit modbus.m_fc_dcdc_power->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_dcdc_power=" << modbus.m_fc_dcdc_power->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_dcdc_power_t store={};
    const QString m_name = "fc_dcdc_power";
};

class modbusQtMessage_fc_dcdc_current : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fc_dcdc_current_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fc_dcdc_current;
        if ((false) || (modbus.m_fc_dcdc_current->m_val != x)) {
            modbus.m_fc_dcdc_current->m_val = x;
            if (!false) {
                emit modbus.m_fc_dcdc_current->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fc_dcdc_current=" << modbus.m_fc_dcdc_current->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fc_dcdc_current_t store={};
    const QString m_name = "fc_dcdc_current";
};

class modbusQtMessage_fcstack_current : public modbusQtMessage
{
    Q_OBJECT

    Q_PROPERTY(QString name MEMBER m_name CONSTANT)

    using modbusQtMessage::modbusQtMessage;

    void received(const QModbusDataUnit &frame) {
        float x;
        Q_UNUSED(x);
        modbusQtSignals &modbus = modbusQtSignals::instance();

        m_timestamp = QDateTime::currentMSecsSinceEpoch();

        if (!m_valid) {
            m_valid = true;
            emit on_valid(QDateTime::fromMSecsSinceEpoch(m_timestamp));
        }

        if (is_extended != true) return;
        if (m_length != static_cast<uint>(frame.valueCount() * 2)) return;

        modbus_fcstack_current_unpack(
                    &store,
                    reinterpret_cast<unsigned char*>(frame.values().data())
                    );

        x = store.fcstack_current;
        if ((false) || (modbus.m_fcstack_current->m_val != x)) {
            modbus.m_fcstack_current->m_val = x;
            if (!false) {
                emit modbus.m_fcstack_current->changed(QDateTime::fromMSecsSinceEpoch(m_timestamp));
            }
            qCDebug(rgm_cantools_modbus) << hex << "m_fcstack_current=" << modbus.m_fcstack_current->m_val;
        }

    }

    
public slots:
    void send_frame();

public:
    struct modbus_fcstack_current_t store={};
    const QString m_name = "fcstack_current";
};


/**
 * Class that groups all messages
 */
class modbusQtMessages : public QObject
{
    Q_OBJECT
    
    Q_PROPERTY(modbusQtMessage* dc_bus_current MEMBER dc_bus_current CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_max_state MEMBER fc_power_max_state CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_sp MEMBER fc_power_sp CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_max_available_power MEMBER dcdc_max_available_power CONSTANT)
    Q_PROPERTY(modbusQtMessage* msg_40204 MEMBER msg_40204 CONSTANT)
    Q_PROPERTY(modbusQtMessage* msg_30201 MEMBER msg_30201 CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_min MEMBER fc_power_min CONSTANT)
    Q_PROPERTY(modbusQtMessage* pos_mix_valve MEMBER pos_mix_valve CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_dcdc_status MEMBER fc_dcdc_status CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_warning_word_3 MEMBER dcdc_warning_word_3 CONSTANT)
    Q_PROPERTY(modbusQtMessage* fcstack_voltage MEMBER fcstack_voltage CONSTANT)
    Q_PROPERTY(modbusQtMessage* msg_30052 MEMBER msg_30052 CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_pwr_unit_temperature MEMBER dcdc_pwr_unit_temperature CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_voltage MEMBER dcdc_voltage CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_extended_info MEMBER fc_extended_info CONSTANT)
    Q_PROPERTY(modbusQtMessage* msg_30051 MEMBER msg_30051 CONSTANT)
    Q_PROPERTY(modbusQtMessage* estimated_time_to_power MEMBER estimated_time_to_power CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_command MEMBER dcdc_command CONSTANT)
    Q_PROPERTY(modbusQtMessage* estimated_time_for_shutdown MEMBER estimated_time_for_shutdown CONSTANT)
    Q_PROPERTY(modbusQtMessage* dc_bus_voltage MEMBER dc_bus_voltage CONSTANT)
    Q_PROPERTY(modbusQtMessage* tcm_hs_sec_in_sp MEMBER tcm_hs_sec_in_sp CONSTANT)
    Q_PROPERTY(modbusQtMessage* power_current_mode MEMBER power_current_mode CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_event_code MEMBER fc_event_code CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_act MEMBER fc_power_act CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_max_available_fc_current MEMBER dcdc_max_available_fc_current CONSTANT)
    Q_PROPERTY(modbusQtMessage* power_current_min_handling MEMBER power_current_min_handling CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_max_available_current MEMBER dcdc_max_available_current CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_warning_word_1 MEMBER dcdc_warning_word_1 CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_status MEMBER dcdc_status CONSTANT)
    Q_PROPERTY(modbusQtMessage* tcm_hs_pri_out MEMBER tcm_hs_pri_out CONSTANT)
    Q_PROPERTY(modbusQtMessage* dcdc_warning_word_2 MEMBER dcdc_warning_word_2 CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_peripheral MEMBER fc_power_peripheral CONSTANT)
    Q_PROPERTY(modbusQtMessage* msg_30053 MEMBER msg_30053 CONSTANT)
    Q_PROPERTY(modbusQtMessage* fcstack_status MEMBER fcstack_status CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_opt MEMBER fc_power_opt CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_dcdc_power_limitation MEMBER fc_dcdc_power_limitation CONSTANT)
    Q_PROPERTY(modbusQtMessage* power_current_reference MEMBER power_current_reference CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_power_max MEMBER fc_power_max CONSTANT)
    Q_PROPERTY(modbusQtMessage* msg_30101 MEMBER msg_30101 CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_dcdc_power MEMBER fc_dcdc_power CONSTANT)
    Q_PROPERTY(modbusQtMessage* fc_dcdc_current MEMBER fc_dcdc_current CONSTANT)
    Q_PROPERTY(modbusQtMessage* fcstack_current MEMBER fcstack_current CONSTANT)

signals:
    void sendFrame(const QModbusDataUnit &frame , uint stationAddress) const;
    void update(const uint m_stationAddress, const uint m_frameId, const uint wlength);

private:
    modbusQtMessages(QObject * = nullptr) {

        map[0x753a] = dc_bus_current = new modbusQtMessage_dc_bus_current(1, 0x753a, true, 2, 0);
        map[0x7601] = fc_power_max_state = new modbusQtMessage_fc_power_max_state(1, 0x7601, true, 2, 0);
        map[0x7605] = fc_power_sp = new modbusQtMessage_fc_power_sp(1, 0x7605, true, 2, 0);
        map[0x7536] = dcdc_max_available_power = new modbusQtMessage_dcdc_max_available_power(1, 0x7536, true, 2, 0);
        map[0x9d0c] = msg_40204 = new modbusQtMessage_msg_40204(1, 0x9d0c, true, 2, 0);
        map[0x75f9] = msg_30201 = new modbusQtMessage_msg_30201(1, 0x75f9, true, 2, 0);
        map[0x7602] = fc_power_min = new modbusQtMessage_fc_power_min(1, 0x7602, true, 2, 0);
        map[0x75fa] = pos_mix_valve = new modbusQtMessage_pos_mix_valve(1, 0x75fa, true, 2, 0);
        map[0x9c41] = fc_dcdc_status = new modbusQtMessage_fc_dcdc_status(1, 0x9c41, true, 2, 0);
        map[0x756f] = dcdc_warning_word_3 = new modbusQtMessage_dcdc_warning_word_3(1, 0x756f, true, 2, 0);
        map[0x7537] = fcstack_voltage = new modbusQtMessage_fcstack_voltage(1, 0x7537, true, 2, 0);
        map[0x7564] = msg_30052 = new modbusQtMessage_msg_30052(1, 0x7564, true, 2, 0);
        map[0x7533] = dcdc_pwr_unit_temperature = new modbusQtMessage_dcdc_pwr_unit_temperature(1, 0x7533, true, 2, 0);
        map[0x9c43] = dcdc_voltage = new modbusQtMessage_dcdc_voltage(1, 0x9c43, true, 2, 0);
        map[0x762d] = fc_extended_info = new modbusQtMessage_fc_extended_info(1, 0x762d, true, 4, 0);
        map[0x7563] = msg_30051 = new modbusQtMessage_msg_30051(1, 0x7563, true, 2, 0);
        map[0x7603] = estimated_time_to_power = new modbusQtMessage_estimated_time_to_power(1, 0x7603, true, 2, 0);
        map[0x9c47] = dcdc_command = new modbusQtMessage_dcdc_command(1, 0x9c47, true, 2, 0);
        map[0x7604] = estimated_time_for_shutdown = new modbusQtMessage_estimated_time_for_shutdown(1, 0x7604, true, 2, 0);
        map[0x7539] = dc_bus_voltage = new modbusQtMessage_dc_bus_voltage(1, 0x7539, true, 2, 0);
        map[0x75fc] = tcm_hs_sec_in_sp = new modbusQtMessage_tcm_hs_sec_in_sp(1, 0x75fc, true, 2, 0);
        map[0x9d09] = power_current_mode = new modbusQtMessage_power_current_mode(1, 0x9d09, true, 2, 0);
        map[0x762b] = fc_event_code = new modbusQtMessage_fc_event_code(1, 0x762b, true, 4, 0);
        map[0x75fd] = fc_power_act = new modbusQtMessage_fc_power_act(1, 0x75fd, true, 2, 0);
        map[0x7535] = dcdc_max_available_fc_current = new modbusQtMessage_dcdc_max_available_fc_current(1, 0x7535, true, 2, 0);
        map[0x9d0b] = power_current_min_handling = new modbusQtMessage_power_current_min_handling(1, 0x9d0b, true, 2, 0);
        map[0x7534] = dcdc_max_available_current = new modbusQtMessage_dcdc_max_available_current(1, 0x7534, true, 2, 0);
        map[0x756d] = dcdc_warning_word_1 = new modbusQtMessage_dcdc_warning_word_1(1, 0x756d, true, 2, 0);
        map[0x7532] = dcdc_status = new modbusQtMessage_dcdc_status(1, 0x7532, true, 2, 0);
        map[0x75fb] = tcm_hs_pri_out = new modbusQtMessage_tcm_hs_pri_out(1, 0x75fb, true, 2, 0);
        map[0x756e] = dcdc_warning_word_2 = new modbusQtMessage_dcdc_warning_word_2(1, 0x756e, true, 2, 0);
        map[0x75fe] = fc_power_peripheral = new modbusQtMessage_fc_power_peripheral(1, 0x75fe, true, 2, 0);
        map[0x7565] = msg_30053 = new modbusQtMessage_msg_30053(1, 0x7565, true, 2, 0);
        map[0x7531] = fcstack_status = new modbusQtMessage_fcstack_status(1, 0x7531, true, 2, 0);
        map[0x75ff] = fc_power_opt = new modbusQtMessage_fc_power_opt(1, 0x75ff, true, 2, 0);
        map[0x9c46] = fc_dcdc_power_limitation = new modbusQtMessage_fc_dcdc_power_limitation(1, 0x9c46, true, 2, 0);
        map[0x9d0a] = power_current_reference = new modbusQtMessage_power_current_reference(1, 0x9d0a, true, 2, 0);
        map[0x7600] = fc_power_max = new modbusQtMessage_fc_power_max(1, 0x7600, true, 2, 0);
        map[0x7595] = msg_30101 = new modbusQtMessage_msg_30101(1, 0x7595, true, 2, 0);
        map[0x9c45] = fc_dcdc_power = new modbusQtMessage_fc_dcdc_power(1, 0x9c45, true, 2, 0);
        map[0x9c44] = fc_dcdc_current = new modbusQtMessage_fc_dcdc_current(1, 0x9c44, true, 2, 0);
        map[0x7538] = fcstack_current = new modbusQtMessage_fcstack_current(1, 0x7538, true, 2, 0);

    }

public:
    modbusQtMessage* dc_bus_current;
    modbusQtMessage* fc_power_max_state;
    modbusQtMessage* fc_power_sp;
    modbusQtMessage* dcdc_max_available_power;
    modbusQtMessage* msg_40204;
    modbusQtMessage* msg_30201;
    modbusQtMessage* fc_power_min;
    modbusQtMessage* pos_mix_valve;
    modbusQtMessage* fc_dcdc_status;
    modbusQtMessage* dcdc_warning_word_3;
    modbusQtMessage* fcstack_voltage;
    modbusQtMessage* msg_30052;
    modbusQtMessage* dcdc_pwr_unit_temperature;
    modbusQtMessage* dcdc_voltage;
    modbusQtMessage* fc_extended_info;
    modbusQtMessage* msg_30051;
    modbusQtMessage* estimated_time_to_power;
    modbusQtMessage* dcdc_command;
    modbusQtMessage* estimated_time_for_shutdown;
    modbusQtMessage* dc_bus_voltage;
    modbusQtMessage* tcm_hs_sec_in_sp;
    modbusQtMessage* power_current_mode;
    modbusQtMessage* fc_event_code;
    modbusQtMessage* fc_power_act;
    modbusQtMessage* dcdc_max_available_fc_current;
    modbusQtMessage* power_current_min_handling;
    modbusQtMessage* dcdc_max_available_current;
    modbusQtMessage* dcdc_warning_word_1;
    modbusQtMessage* dcdc_status;
    modbusQtMessage* tcm_hs_pri_out;
    modbusQtMessage* dcdc_warning_word_2;
    modbusQtMessage* fc_power_peripheral;
    modbusQtMessage* msg_30053;
    modbusQtMessage* fcstack_status;
    modbusQtMessage* fc_power_opt;
    modbusQtMessage* fc_dcdc_power_limitation;
    modbusQtMessage* power_current_reference;
    modbusQtMessage* fc_power_max;
    modbusQtMessage* msg_30101;
    modbusQtMessage* fc_dcdc_power;
    modbusQtMessage* fc_dcdc_current;
    modbusQtMessage* fcstack_current;

public slots:
    void periodic_check_validity() {
        qint64 now = QDateTime::currentMSecsSinceEpoch();
        Q_UNUSED(now);
        // qint64 deltat = now - m_timestamp;


    }

public:
    QMap<uint, modbusQtMessage*> map;
    static modbusQtMessages& instance() {
        static modbusQtMessages * _instance = nullptr;
        if ( _instance == nullptr ) {
            _instance = new modbusQtMessages();
        }
        return *_instance;
    }

    void can_receive_frame_callback(const QModbusDataUnit &frame);

};

#endif // close MODBUS_QT_H
