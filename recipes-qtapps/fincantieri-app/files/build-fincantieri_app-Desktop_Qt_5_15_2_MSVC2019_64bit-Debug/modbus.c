/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.4.12 Tue Aug  2 15:22:19 2022.
 */

#include <string.h>
#include <math.h>

#include "modbus.h"

#ifdef __TMS320C2000__
#pragma diag_suppress 179 // ignore warnings for unused variables
#pragma diag_suppress 190 // ignore enumerated type mixed with another type
#endif

#define encode_scale_offset(value, scale, offset) ((value - offset) * scale)
#define decode_scale_offset(value, factor, offset) ((value * factor) + offset)

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

/**
 * Pack message FC_DCDC_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_dcdc_status_pack(
    uint8_t *dst_p,
    const struct modbus_fc_dcdc_status_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->fc_dcdc_running, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->fc_dcdc_failure, 1u, 0x02u);

    return (2);
}
/**
 * Unpack message FC_DCDC_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_dcdc_status_unpack(
    struct modbus_fc_dcdc_status_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->fc_dcdc_running = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->fc_dcdc_failure = unpack_right_shift_u8(src_p[0], 1u, 0x02u);

    
    
    return (0);
}

uint8_t modbus_fc_dcdc_status_fc_dcdc_running_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_fc_dcdc_status_fc_dcdc_running_decode(uint8_t value)
{
    return ((float)value);
}


uint8_t modbus_fc_dcdc_status_fc_dcdc_failure_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_fc_dcdc_status_fc_dcdc_failure_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message DCDC_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_voltage_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_voltage_t *src_p)
{
    uint16_t dcdc_voltage=0;


    memset(dst_p, 0, 2);

        
    dcdc_voltage = (uint16_t)modbus_dcdc_voltage_dcdc_voltage_encode(src_p->dcdc_voltage);
    dst_p[0] |= pack_left_shift_u16(dcdc_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dcdc_voltage, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_voltage_unpack(
    struct modbus_dcdc_voltage_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dcdc_voltage;


    dcdc_voltage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dcdc_voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dcdc_voltage = modbus_dcdc_voltage_dcdc_voltage_decode((uint16_t)dcdc_voltage);

    
    
    return (0);
}

uint16_t modbus_dcdc_voltage_dcdc_voltage_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_dcdc_voltage_dcdc_voltage_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message FC_DCDC_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_dcdc_current_pack(
    uint8_t *dst_p,
    const struct modbus_fc_dcdc_current_t *src_p)
{
    uint16_t fc_dcdc_current=0;


    memset(dst_p, 0, 2);

        
    fc_dcdc_current = (uint16_t)modbus_fc_dcdc_current_fc_dcdc_current_encode(src_p->fc_dcdc_current);
    dst_p[0] |= pack_left_shift_u16(fc_dcdc_current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_dcdc_current, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_DCDC_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_dcdc_current_unpack(
    struct modbus_fc_dcdc_current_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_dcdc_current;


    fc_dcdc_current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_dcdc_current |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_dcdc_current = modbus_fc_dcdc_current_fc_dcdc_current_decode((int16_t)fc_dcdc_current);

    
    
    return (0);
}

int16_t modbus_fc_dcdc_current_fc_dcdc_current_encode(float value)
{
    return (int16_t)(roundf(value / 0.01f));
}

float modbus_fc_dcdc_current_fc_dcdc_current_decode(int16_t value)
{
    return ((float)value * 0.01f);
}


/**
 * Pack message FC_DCDC_POWER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_dcdc_power_pack(
    uint8_t *dst_p,
    const struct modbus_fc_dcdc_power_t *src_p)
{
    uint16_t fc_dcdc_power=0;


    memset(dst_p, 0, 2);

        
    fc_dcdc_power = (uint16_t)modbus_fc_dcdc_power_fc_dcdc_power_encode(src_p->fc_dcdc_power);
    dst_p[0] |= pack_left_shift_u16(fc_dcdc_power, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_dcdc_power, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_DCDC_POWER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_dcdc_power_unpack(
    struct modbus_fc_dcdc_power_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_dcdc_power;


    fc_dcdc_power = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_dcdc_power |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_dcdc_power = modbus_fc_dcdc_power_fc_dcdc_power_decode((int16_t)fc_dcdc_power);

    
    
    return (0);
}

int16_t modbus_fc_dcdc_power_fc_dcdc_power_encode(float value)
{
    return (int16_t)(roundf(value / 0.01f));
}

float modbus_fc_dcdc_power_fc_dcdc_power_decode(int16_t value)
{
    return ((float)value * 0.01f);
}


/**
 * Pack message FC_DCDC_POWER_LIMITATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_dcdc_power_limitation_pack(
    uint8_t *dst_p,
    const struct modbus_fc_dcdc_power_limitation_t *src_p)
{
    uint16_t fc_dcdc_power_limitation=0;


    memset(dst_p, 0, 2);

        
    fc_dcdc_power_limitation = (uint16_t)modbus_fc_dcdc_power_limitation_fc_dcdc_power_limitation_encode(src_p->fc_dcdc_power_limitation);
    dst_p[0] |= pack_left_shift_u16(fc_dcdc_power_limitation, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_dcdc_power_limitation, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_DCDC_POWER_LIMITATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_dcdc_power_limitation_unpack(
    struct modbus_fc_dcdc_power_limitation_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_dcdc_power_limitation;


    fc_dcdc_power_limitation = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_dcdc_power_limitation |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_dcdc_power_limitation = modbus_fc_dcdc_power_limitation_fc_dcdc_power_limitation_decode((int16_t)fc_dcdc_power_limitation);

    
    
    return (0);
}

int16_t modbus_fc_dcdc_power_limitation_fc_dcdc_power_limitation_encode(float value)
{
    return (int16_t)(roundf(value / 0.01f));
}

float modbus_fc_dcdc_power_limitation_fc_dcdc_power_limitation_decode(int16_t value)
{
    return ((float)value * 0.01f);
}


/**
 * Pack message DCDC_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_command_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_command_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->dcdc_reset2, 0u, 0x01u);

    return (2);
}
/**
 * Unpack message DCDC_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_command_unpack(
    struct modbus_dcdc_command_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_reset2 = unpack_right_shift_u8(src_p[0], 0u, 0x01u);

    
    
    return (0);
}

uint8_t modbus_dcdc_command_dcdc_reset2_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_dcdc_command_dcdc_reset2_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message FCSTACK_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fcstack_status_pack(
    uint8_t *dst_p,
    const struct modbus_fcstack_status_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->fcstack_status, 0u, 0xffu);

    return (2);
}
/**
 * Unpack message FCSTACK_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fcstack_status_unpack(
    struct modbus_fcstack_status_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->fcstack_status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    
    
    return (0);
}

uint8_t modbus_fcstack_status_fcstack_status_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_fcstack_status_fcstack_status_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message DCDC_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_status_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_status_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->dcdc_status, 0u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_status_unpack(
    struct modbus_dcdc_status_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_status = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    
    
    return (0);
}

uint8_t modbus_dcdc_status_dcdc_status_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_dcdc_status_dcdc_status_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message DCDC_PWR_UNIT_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_pwr_unit_temperature_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_pwr_unit_temperature_t *src_p)
{
    uint16_t dcdc_pwr_unit_temperature=0;


    memset(dst_p, 0, 2);

        
    dcdc_pwr_unit_temperature = (uint16_t)modbus_dcdc_pwr_unit_temperature_dcdc_pwr_unit_temperature_encode(src_p->dcdc_pwr_unit_temperature);
    dst_p[0] |= pack_left_shift_u16(dcdc_pwr_unit_temperature, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dcdc_pwr_unit_temperature, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_PWR_UNIT_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_pwr_unit_temperature_unpack(
    struct modbus_dcdc_pwr_unit_temperature_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dcdc_pwr_unit_temperature;


    dcdc_pwr_unit_temperature = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dcdc_pwr_unit_temperature |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dcdc_pwr_unit_temperature = modbus_dcdc_pwr_unit_temperature_dcdc_pwr_unit_temperature_decode((uint16_t)dcdc_pwr_unit_temperature);

    
    
    return (0);
}

uint16_t modbus_dcdc_pwr_unit_temperature_dcdc_pwr_unit_temperature_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_dcdc_pwr_unit_temperature_dcdc_pwr_unit_temperature_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message DCDC_MAX_AVAILABLE_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_max_available_current_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_max_available_current_t *src_p)
{
    uint16_t dcdc_max_available_current=0;


    memset(dst_p, 0, 2);

        
    dcdc_max_available_current = (uint16_t)modbus_dcdc_max_available_current_dcdc_max_available_current_encode(src_p->dcdc_max_available_current);
    dst_p[0] |= pack_left_shift_u16(dcdc_max_available_current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dcdc_max_available_current, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_MAX_AVAILABLE_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_max_available_current_unpack(
    struct modbus_dcdc_max_available_current_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dcdc_max_available_current;


    dcdc_max_available_current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dcdc_max_available_current |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dcdc_max_available_current = modbus_dcdc_max_available_current_dcdc_max_available_current_decode((uint16_t)dcdc_max_available_current);

    
    
    return (0);
}

uint16_t modbus_dcdc_max_available_current_dcdc_max_available_current_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_dcdc_max_available_current_dcdc_max_available_current_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message DCDC_MAX_AVAILABLE_FC_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_max_available_fc_current_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_max_available_fc_current_t *src_p)
{
    uint16_t dcdc_max_available_fc_current=0;


    memset(dst_p, 0, 2);

        
    dcdc_max_available_fc_current = (uint16_t)modbus_dcdc_max_available_fc_current_dcdc_max_available_fc_current_encode(src_p->dcdc_max_available_fc_current);
    dst_p[0] |= pack_left_shift_u16(dcdc_max_available_fc_current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dcdc_max_available_fc_current, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_MAX_AVAILABLE_FC_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_max_available_fc_current_unpack(
    struct modbus_dcdc_max_available_fc_current_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dcdc_max_available_fc_current;


    dcdc_max_available_fc_current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dcdc_max_available_fc_current |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dcdc_max_available_fc_current = modbus_dcdc_max_available_fc_current_dcdc_max_available_fc_current_decode((uint16_t)dcdc_max_available_fc_current);

    
    
    return (0);
}

uint16_t modbus_dcdc_max_available_fc_current_dcdc_max_available_fc_current_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_dcdc_max_available_fc_current_dcdc_max_available_fc_current_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message DCDC_MAX_AVAILABLE_POWER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_max_available_power_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_max_available_power_t *src_p)
{
    uint16_t dcdc_max_available_power=0;


    memset(dst_p, 0, 2);

        
    dcdc_max_available_power = (uint16_t)modbus_dcdc_max_available_power_dcdc_max_available_power_encode(src_p->dcdc_max_available_power);
    dst_p[0] |= pack_left_shift_u16(dcdc_max_available_power, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dcdc_max_available_power, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_MAX_AVAILABLE_POWER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_max_available_power_unpack(
    struct modbus_dcdc_max_available_power_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dcdc_max_available_power;


    dcdc_max_available_power = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dcdc_max_available_power |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dcdc_max_available_power = modbus_dcdc_max_available_power_dcdc_max_available_power_decode((uint16_t)dcdc_max_available_power);

    
    
    return (0);
}

uint16_t modbus_dcdc_max_available_power_dcdc_max_available_power_encode(float value)
{
    return (uint16_t)(roundf(value / 0.01f));
}

float modbus_dcdc_max_available_power_dcdc_max_available_power_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}


/**
 * Pack message FCSTACK_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fcstack_voltage_pack(
    uint8_t *dst_p,
    const struct modbus_fcstack_voltage_t *src_p)
{
    uint16_t fcstack_voltage=0;


    memset(dst_p, 0, 2);

        
    fcstack_voltage = (uint16_t)modbus_fcstack_voltage_fcstack_voltage_encode(src_p->fcstack_voltage);
    dst_p[0] |= pack_left_shift_u16(fcstack_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fcstack_voltage, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FCSTACK_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fcstack_voltage_unpack(
    struct modbus_fcstack_voltage_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fcstack_voltage;


    fcstack_voltage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fcstack_voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fcstack_voltage = modbus_fcstack_voltage_fcstack_voltage_decode((uint16_t)fcstack_voltage);

    
    
    return (0);
}

uint16_t modbus_fcstack_voltage_fcstack_voltage_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_fcstack_voltage_fcstack_voltage_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message FCSTACK_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fcstack_current_pack(
    uint8_t *dst_p,
    const struct modbus_fcstack_current_t *src_p)
{
    uint16_t fcstack_current=0;


    memset(dst_p, 0, 2);

        
    fcstack_current = (uint16_t)modbus_fcstack_current_fcstack_current_encode(src_p->fcstack_current);
    dst_p[0] |= pack_left_shift_u16(fcstack_current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fcstack_current, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FCSTACK_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fcstack_current_unpack(
    struct modbus_fcstack_current_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fcstack_current;


    fcstack_current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fcstack_current |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fcstack_current = modbus_fcstack_current_fcstack_current_decode((uint16_t)fcstack_current);

    
    
    return (0);
}

uint16_t modbus_fcstack_current_fcstack_current_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_fcstack_current_fcstack_current_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message DC_BUS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dc_bus_voltage_pack(
    uint8_t *dst_p,
    const struct modbus_dc_bus_voltage_t *src_p)
{
    uint16_t dc_bus_voltage=0;


    memset(dst_p, 0, 2);

        
    dc_bus_voltage = (uint16_t)modbus_dc_bus_voltage_dc_bus_voltage_encode(src_p->dc_bus_voltage);
    dst_p[0] |= pack_left_shift_u16(dc_bus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dc_bus_voltage, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DC_BUS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dc_bus_voltage_unpack(
    struct modbus_dc_bus_voltage_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dc_bus_voltage;


    dc_bus_voltage = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dc_bus_voltage |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dc_bus_voltage = modbus_dc_bus_voltage_dc_bus_voltage_decode((uint16_t)dc_bus_voltage);

    
    
    return (0);
}

uint16_t modbus_dc_bus_voltage_dc_bus_voltage_encode(float value)
{
    return (uint16_t)(roundf(value / 0.1f));
}

float modbus_dc_bus_voltage_dc_bus_voltage_decode(uint16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message DC_BUS_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dc_bus_current_pack(
    uint8_t *dst_p,
    const struct modbus_dc_bus_current_t *src_p)
{
    uint16_t dc_bus_current=0;


    memset(dst_p, 0, 2);

        
    dc_bus_current = (uint16_t)modbus_dc_bus_current_dc_bus_current_encode(src_p->dc_bus_current);
    dst_p[0] |= pack_left_shift_u16(dc_bus_current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(dc_bus_current, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DC_BUS_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dc_bus_current_unpack(
    struct modbus_dc_bus_current_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t dc_bus_current;


    dc_bus_current = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dc_bus_current |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->dc_bus_current = modbus_dc_bus_current_dc_bus_current_decode((uint16_t)dc_bus_current);

    
    
    return (0);
}

uint16_t modbus_dc_bus_current_dc_bus_current_encode(float value)
{
    return (uint16_t)(roundf(value / 0.01f));
}

float modbus_dc_bus_current_dc_bus_current_decode(uint16_t value)
{
    return ((float)value * 0.01f);
}


/**
 * Pack message Msg_30051.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_msg_30051_pack(
    uint8_t *dst_p,
    const struct modbus_msg_30051_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_error_word_1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_error_word_1, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message Msg_30051.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_msg_30051_unpack(
    struct modbus_msg_30051_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_error_word_1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_error_word_1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_msg_30051_dcdc_error_word_1_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_msg_30051_dcdc_error_word_1_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message Msg_30052.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_msg_30052_pack(
    uint8_t *dst_p,
    const struct modbus_msg_30052_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_error_word_2, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_error_word_2, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message Msg_30052.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_msg_30052_unpack(
    struct modbus_msg_30052_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_error_word_2 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_error_word_2 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_msg_30052_dcdc_error_word_2_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_msg_30052_dcdc_error_word_2_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message Msg_30053.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_msg_30053_pack(
    uint8_t *dst_p,
    const struct modbus_msg_30053_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_error_word_3, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_error_word_3, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message Msg_30053.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_msg_30053_unpack(
    struct modbus_msg_30053_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_error_word_3 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_error_word_3 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_msg_30053_dcdc_error_word_3_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_msg_30053_dcdc_error_word_3_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message DCDC_WARNING_WORD_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_warning_word_1_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_warning_word_1_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_warning_word_1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_warning_word_1, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_WARNING_WORD_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_warning_word_1_unpack(
    struct modbus_dcdc_warning_word_1_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_warning_word_1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_warning_word_1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_dcdc_warning_word_1_dcdc_warning_word_1_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_dcdc_warning_word_1_dcdc_warning_word_1_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message DCDC_WARNING_WORD_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_warning_word_2_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_warning_word_2_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_warning_word_2, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_warning_word_2, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_WARNING_WORD_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_warning_word_2_unpack(
    struct modbus_dcdc_warning_word_2_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_warning_word_2 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_warning_word_2 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_dcdc_warning_word_2_dcdc_warning_word_2_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_dcdc_warning_word_2_dcdc_warning_word_2_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message DCDC_WARNING_WORD_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_dcdc_warning_word_3_pack(
    uint8_t *dst_p,
    const struct modbus_dcdc_warning_word_3_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_warning_word_3, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_warning_word_3, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message DCDC_WARNING_WORD_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_dcdc_warning_word_3_unpack(
    struct modbus_dcdc_warning_word_3_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_warning_word_3 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_warning_word_3 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_dcdc_warning_word_3_dcdc_warning_word_3_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_dcdc_warning_word_3_dcdc_warning_word_3_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message Msg_30101.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_msg_30101_pack(
    uint8_t *dst_p,
    const struct modbus_msg_30101_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->dcdc_status_word_1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->dcdc_status_word_1, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message Msg_30101.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_msg_30101_unpack(
    struct modbus_msg_30101_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->dcdc_status_word_1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->dcdc_status_word_1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_msg_30101_dcdc_status_word_1_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_msg_30101_dcdc_status_word_1_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message PowerCurrentMode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_power_current_mode_pack(
    uint8_t *dst_p,
    const struct modbus_power_current_mode_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->power_current_mode, 0u, 0xffu);

    return (2);
}
/**
 * Unpack message PowerCurrentMode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_power_current_mode_unpack(
    struct modbus_power_current_mode_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->power_current_mode = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    
    
    return (0);
}

uint8_t modbus_power_current_mode_power_current_mode_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_power_current_mode_power_current_mode_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message PowerCurrentReference.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_power_current_reference_pack(
    uint8_t *dst_p,
    const struct modbus_power_current_reference_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->power_current_reference, 0u, 0xffu);

    return (2);
}
/**
 * Unpack message PowerCurrentReference.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_power_current_reference_unpack(
    struct modbus_power_current_reference_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->power_current_reference = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    
    
    return (0);
}

uint8_t modbus_power_current_reference_power_current_reference_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_power_current_reference_power_current_reference_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message PowerCurrentMinHandling.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_power_current_min_handling_pack(
    uint8_t *dst_p,
    const struct modbus_power_current_min_handling_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->power_current_min_handling, 0u, 0xffu);

    return (2);
}
/**
 * Unpack message PowerCurrentMinHandling.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_power_current_min_handling_unpack(
    struct modbus_power_current_min_handling_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->power_current_min_handling = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    
    
    return (0);
}

uint8_t modbus_power_current_min_handling_power_current_min_handling_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_power_current_min_handling_power_current_min_handling_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message Msg_40204.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_msg_40204_pack(
    uint8_t *dst_p,
    const struct modbus_msg_40204_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->system_off_request, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->fast_shutdown_request, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->freeze_protection_request, 2u, 0x04u);

    return (2);
}
/**
 * Unpack message Msg_40204.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_msg_40204_unpack(
    struct modbus_msg_40204_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->system_off_request = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->fast_shutdown_request = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->freeze_protection_request = unpack_right_shift_u8(src_p[0], 2u, 0x04u);

    
    
    return (0);
}

uint8_t modbus_msg_40204_system_off_request_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_msg_40204_system_off_request_decode(uint8_t value)
{
    return ((float)value);
}


uint8_t modbus_msg_40204_fast_shutdown_request_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_msg_40204_fast_shutdown_request_decode(uint8_t value)
{
    return ((float)value);
}


uint8_t modbus_msg_40204_freeze_protection_request_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_msg_40204_freeze_protection_request_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message Msg_30201.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_msg_30201_pack(
    uint8_t *dst_p,
    const struct modbus_msg_30201_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->mute_h2_sens_exhaust2, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->status_freeze_protection, 1u, 0x02u);

    return (2);
}
/**
 * Unpack message Msg_30201.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_msg_30201_unpack(
    struct modbus_msg_30201_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->mute_h2_sens_exhaust2 = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->status_freeze_protection = unpack_right_shift_u8(src_p[0], 1u, 0x02u);

    
    
    return (0);
}

uint8_t modbus_msg_30201_mute_h2_sens_exhaust2_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_msg_30201_mute_h2_sens_exhaust2_decode(uint8_t value)
{
    return ((float)value);
}


uint8_t modbus_msg_30201_status_freeze_protection_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_msg_30201_status_freeze_protection_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message Pos_Mix_Valve.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_pos_mix_valve_pack(
    uint8_t *dst_p,
    const struct modbus_pos_mix_valve_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u8(src_p->pos_mix_valve2, 0u, 0xffu);

    return (2);
}
/**
 * Unpack message Pos_Mix_Valve.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_pos_mix_valve_unpack(
    struct modbus_pos_mix_valve_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->pos_mix_valve2 = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    
    
    return (0);
}

uint8_t modbus_pos_mix_valve_pos_mix_valve2_encode(float value)
{
    return (uint8_t)(roundf(value));
}

float modbus_pos_mix_valve_pos_mix_valve2_decode(uint8_t value)
{
    return ((float)value);
}


/**
 * Pack message Tcm_Hs_Pri_Out.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_tcm_hs_pri_out_pack(
    uint8_t *dst_p,
    const struct modbus_tcm_hs_pri_out_t *src_p)
{
    uint16_t tcm_hs_pri_out2=0;


    memset(dst_p, 0, 2);

        
    tcm_hs_pri_out2 = (uint16_t)modbus_tcm_hs_pri_out_tcm_hs_pri_out2_encode(src_p->tcm_hs_pri_out2);
    dst_p[0] |= pack_left_shift_u16(tcm_hs_pri_out2, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(tcm_hs_pri_out2, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message Tcm_Hs_Pri_Out.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_tcm_hs_pri_out_unpack(
    struct modbus_tcm_hs_pri_out_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t tcm_hs_pri_out2;


    tcm_hs_pri_out2 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    tcm_hs_pri_out2 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->tcm_hs_pri_out2 = modbus_tcm_hs_pri_out_tcm_hs_pri_out2_decode((int16_t)tcm_hs_pri_out2);

    
    
    return (0);
}

int16_t modbus_tcm_hs_pri_out_tcm_hs_pri_out2_encode(float value)
{
    return (int16_t)(roundf(value / 0.1f));
}

float modbus_tcm_hs_pri_out_tcm_hs_pri_out2_decode(int16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message Tcm_Hs_Sec_In_Sp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_tcm_hs_sec_in_sp_pack(
    uint8_t *dst_p,
    const struct modbus_tcm_hs_sec_in_sp_t *src_p)
{
    uint16_t tcm_hs_sec_in_sp2=0;


    memset(dst_p, 0, 2);

        
    tcm_hs_sec_in_sp2 = (uint16_t)modbus_tcm_hs_sec_in_sp_tcm_hs_sec_in_sp2_encode(src_p->tcm_hs_sec_in_sp2);
    dst_p[0] |= pack_left_shift_u16(tcm_hs_sec_in_sp2, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(tcm_hs_sec_in_sp2, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message Tcm_Hs_Sec_In_Sp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_tcm_hs_sec_in_sp_unpack(
    struct modbus_tcm_hs_sec_in_sp_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t tcm_hs_sec_in_sp2;


    tcm_hs_sec_in_sp2 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    tcm_hs_sec_in_sp2 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->tcm_hs_sec_in_sp2 = modbus_tcm_hs_sec_in_sp_tcm_hs_sec_in_sp2_decode((int16_t)tcm_hs_sec_in_sp2);

    
    
    return (0);
}

int16_t modbus_tcm_hs_sec_in_sp_tcm_hs_sec_in_sp2_encode(float value)
{
    return (int16_t)(roundf(value / 0.1f));
}

float modbus_tcm_hs_sec_in_sp_tcm_hs_sec_in_sp2_decode(int16_t value)
{
    return ((float)value * 0.1f);
}


/**
 * Pack message FC_POWER_ACT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_act_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_act_t *src_p)
{
    uint16_t fc_power_act=0;


    memset(dst_p, 0, 2);

        
    fc_power_act = (uint16_t)modbus_fc_power_act_fc_power_act_encode(src_p->fc_power_act);
    dst_p[0] |= pack_left_shift_u16(fc_power_act, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_power_act, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_ACT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_act_unpack(
    struct modbus_fc_power_act_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_power_act;


    fc_power_act = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_power_act |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_power_act = modbus_fc_power_act_fc_power_act_decode((uint16_t)fc_power_act);

    
    
    return (0);
}

uint16_t modbus_fc_power_act_fc_power_act_encode(float value)
{
    return (uint16_t)(roundf(value / 10.0f));
}

float modbus_fc_power_act_fc_power_act_decode(uint16_t value)
{
    return ((float)value * 10.0f);
}


/**
 * Pack message FC_POWER_PERIPHERAL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_peripheral_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_peripheral_t *src_p)
{
    uint16_t fc_power_peripheral=0;


    memset(dst_p, 0, 2);

        
    fc_power_peripheral = (uint16_t)modbus_fc_power_peripheral_fc_power_peripheral_encode(src_p->fc_power_peripheral);
    dst_p[0] |= pack_left_shift_u16(fc_power_peripheral, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_power_peripheral, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_PERIPHERAL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_peripheral_unpack(
    struct modbus_fc_power_peripheral_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_power_peripheral;


    fc_power_peripheral = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_power_peripheral |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_power_peripheral = modbus_fc_power_peripheral_fc_power_peripheral_decode((uint16_t)fc_power_peripheral);

    
    
    return (0);
}

uint16_t modbus_fc_power_peripheral_fc_power_peripheral_encode(float value)
{
    return (uint16_t)(roundf(value / 10.0f));
}

float modbus_fc_power_peripheral_fc_power_peripheral_decode(uint16_t value)
{
    return ((float)value * 10.0f);
}


/**
 * Pack message FC_POWER_OPT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_opt_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_opt_t *src_p)
{
    uint16_t fc_power_opt=0;


    memset(dst_p, 0, 2);

        
    fc_power_opt = (uint16_t)modbus_fc_power_opt_fc_power_opt_encode(src_p->fc_power_opt);
    dst_p[0] |= pack_left_shift_u16(fc_power_opt, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_power_opt, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_OPT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_opt_unpack(
    struct modbus_fc_power_opt_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_power_opt;


    fc_power_opt = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_power_opt |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_power_opt = modbus_fc_power_opt_fc_power_opt_decode((uint16_t)fc_power_opt);

    
    
    return (0);
}

uint16_t modbus_fc_power_opt_fc_power_opt_encode(float value)
{
    return (uint16_t)(roundf(value / 10.0f));
}

float modbus_fc_power_opt_fc_power_opt_decode(uint16_t value)
{
    return ((float)value * 10.0f);
}


/**
 * Pack message FC_POWER_MAX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_max_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_max_t *src_p)
{
    uint16_t fc_power_max=0;


    memset(dst_p, 0, 2);

        
    fc_power_max = (uint16_t)modbus_fc_power_max_fc_power_max_encode(src_p->fc_power_max);
    dst_p[0] |= pack_left_shift_u16(fc_power_max, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_power_max, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_MAX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_max_unpack(
    struct modbus_fc_power_max_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_power_max;


    fc_power_max = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_power_max |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_power_max = modbus_fc_power_max_fc_power_max_decode((uint16_t)fc_power_max);

    
    
    return (0);
}

uint16_t modbus_fc_power_max_fc_power_max_encode(float value)
{
    return (uint16_t)(roundf(value / 10.0f));
}

float modbus_fc_power_max_fc_power_max_decode(uint16_t value)
{
    return ((float)value * 10.0f);
}


/**
 * Pack message FC_POWER_MAX_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_max_state_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_max_state_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->fc_power_max_state, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->fc_power_max_state, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_MAX_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_max_state_unpack(
    struct modbus_fc_power_max_state_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->fc_power_max_state = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->fc_power_max_state |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_fc_power_max_state_fc_power_max_state_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_fc_power_max_state_fc_power_max_state_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message FC_POWER_MIN.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_min_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_min_t *src_p)
{
    uint16_t fc_power_min=0;


    memset(dst_p, 0, 2);

        
    fc_power_min = (uint16_t)modbus_fc_power_min_fc_power_min_encode(src_p->fc_power_min);
    dst_p[0] |= pack_left_shift_u16(fc_power_min, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_power_min, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_MIN.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_min_unpack(
    struct modbus_fc_power_min_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_power_min;


    fc_power_min = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_power_min |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_power_min = modbus_fc_power_min_fc_power_min_decode((uint16_t)fc_power_min);

    
    
    return (0);
}

uint16_t modbus_fc_power_min_fc_power_min_encode(float value)
{
    return (uint16_t)(roundf(value / 10.0f));
}

float modbus_fc_power_min_fc_power_min_decode(uint16_t value)
{
    return ((float)value * 10.0f);
}


/**
 * Pack message EstimatedTimeToPower.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_estimated_time_to_power_pack(
    uint8_t *dst_p,
    const struct modbus_estimated_time_to_power_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->estimated_time_to_power, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->estimated_time_to_power, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message EstimatedTimeToPower.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_estimated_time_to_power_unpack(
    struct modbus_estimated_time_to_power_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->estimated_time_to_power = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->estimated_time_to_power |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_estimated_time_to_power_estimated_time_to_power_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_estimated_time_to_power_estimated_time_to_power_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message EstimatedTimeForShutdown.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_estimated_time_for_shutdown_pack(
    uint8_t *dst_p,
    const struct modbus_estimated_time_for_shutdown_t *src_p)
{
    memset(dst_p, 0, 2);

        
    dst_p[0] |= pack_left_shift_u16(src_p->estimated_time_for_shutdown, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->estimated_time_for_shutdown, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message EstimatedTimeForShutdown.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_estimated_time_for_shutdown_unpack(
    struct modbus_estimated_time_for_shutdown_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->estimated_time_for_shutdown = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->estimated_time_for_shutdown |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_estimated_time_for_shutdown_estimated_time_for_shutdown_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_estimated_time_for_shutdown_estimated_time_for_shutdown_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message FC_POWER_SP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_power_sp_pack(
    uint8_t *dst_p,
    const struct modbus_fc_power_sp_t *src_p)
{
    uint16_t fc_power_sp=0;


    memset(dst_p, 0, 2);

        
    fc_power_sp = (uint16_t)modbus_fc_power_sp_fc_power_sp_encode(src_p->fc_power_sp);
    dst_p[0] |= pack_left_shift_u16(fc_power_sp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(fc_power_sp, 8u, 0xffu);

    return (2);
}
/**
 * Unpack message FC_POWER_SP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_power_sp_unpack(
    struct modbus_fc_power_sp_t *dst_p,
    const uint8_t *src_p)
{
    uint16_t fc_power_sp;


    fc_power_sp = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    fc_power_sp |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_power_sp = modbus_fc_power_sp_fc_power_sp_decode((uint16_t)fc_power_sp);

    
    
    return (0);
}

uint16_t modbus_fc_power_sp_fc_power_sp_encode(float value)
{
    return (uint16_t)(roundf(value / 10.0f));
}

float modbus_fc_power_sp_fc_power_sp_decode(uint16_t value)
{
    return ((float)value * 10.0f);
}


/**
 * Pack message FC_EVENT_CODE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_event_code_pack(
    uint8_t *dst_p,
    const struct modbus_fc_event_code_t *src_p)
{
    memset(dst_p, 0, 4);

        
    dst_p[0] |= pack_left_shift_u16(src_p->fc_event_code1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->fc_event_code1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->fc_event_code2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->fc_event_code2, 8u, 0xffu);

    return (4);
}
/**
 * Unpack message FC_EVENT_CODE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_event_code_unpack(
    struct modbus_fc_event_code_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->fc_event_code1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->fc_event_code1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_event_code2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->fc_event_code2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_fc_event_code_fc_event_code1_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_fc_event_code_fc_event_code1_decode(uint16_t value)
{
    return ((float)value);
}


uint16_t modbus_fc_event_code_fc_event_code2_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_fc_event_code_fc_event_code2_decode(uint16_t value)
{
    return ((float)value);
}


/**
 * Pack message FC_EXTENDED_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 *
 * @return Size of packed data, or negative error code.
 */
int modbus_fc_extended_info_pack(
    uint8_t *dst_p,
    const struct modbus_fc_extended_info_t *src_p)
{
    memset(dst_p, 0, 4);

        
    dst_p[0] |= pack_left_shift_u16(src_p->fc_extended_info1, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->fc_extended_info1, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->fc_extended_info2, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->fc_extended_info2, 8u, 0xffu);

    return (4);
}
/**
 * Unpack message FC_EXTENDED_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 *
 * @return zero(0) or negative error code.
 */
int modbus_fc_extended_info_unpack(
    struct modbus_fc_extended_info_t *dst_p,
    const uint8_t *src_p)
{

    dst_p->fc_extended_info1 = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->fc_extended_info1 |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->fc_extended_info2 = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->fc_extended_info2 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    
    
    return (0);
}

uint16_t modbus_fc_extended_info_fc_extended_info1_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_fc_extended_info_fc_extended_info1_decode(uint16_t value)
{
    return ((float)value);
}


uint16_t modbus_fc_extended_info_fc_extended_info2_encode(float value)
{
    return (uint16_t)(roundf(value));
}

float modbus_fc_extended_info_fc_extended_info2_decode(uint16_t value)
{
    return ((float)value);
}

