/**
 * This file was generated by:
 * "C:\Python39\Scripts\cantools generate_qt_source ..\fincantieri-app-fc02-1.2\modbus.dbc --signals all --bit-fields --no-strict --no-size-and-memset"
 * version 36.4.12 Tue Aug  2 15:22:19 2022.
 */

#include "modbus_qt.h"
#include "modbus.h"

#include <QModbusDataUnit>
#include <QDebug>
#include <QLoggingCategory>

Q_LOGGING_CATEGORY(rgm_cantools_modbus, "rgm.cantools.modbus", QtWarningMsg)

int global_server_station_address = 1;

void QVariantHistorySignalmodbus::update(QDateTime t) {
    m_data.append(QPair<QDateTime, QVariant>(t, m_val));
}

void QVariantHistorySignalmodbus::update_valid(QDateTime t) {

/*
    if (this->parent->m_valid) {
        if (m_data.count() > 0)
            m_data.append(QPair<QDateTime, QVariant>(t, QVariant()));
    } else {
        m_data.append(QPair<QDateTime, QVariant>(t, QVariant()));
    }
*/
}

modbusQtSignals::modbusQtSignals(QObject *) {
    m_messages = &modbusQtMessages::instance();
    m_dcdc_warning_word_2 = new QVariantSignal_dcdc_warning_word_2(modbusQtMessages::instance().map[0x756e], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "A", "dcdc_warning_word_2", "");
    m_power_current_reference = new QVariantSignal_power_current_reference(modbusQtMessages::instance().map[0x9d0a], QVariant::fromValue(255), QVariant::fromValue(0), 1, "", "power_current_reference", "");
    m_estimated_time_to_power = new QVariantSignal_estimated_time_to_power(modbusQtMessages::instance().map[0x7603], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "sec", "estimated_time_to_power", "");
    m_dcdc_max_available_current = new QVariantSignal_dcdc_max_available_current(modbusQtMessages::instance().map[0x7534], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "A", "dcdc_max_available_current", "");
    m_power_current_min_handling = new QVariantSignal_power_current_min_handling(modbusQtMessages::instance().map[0x9d0b], QVariant::fromValue(255), QVariant::fromValue(0), 1, "", "power_current_min_handling", "");
    m_fc_extended_info2 = new QVariantSignal_fc_extended_info2(modbusQtMessages::instance().map[0x762d], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "fc_extended_info2", "");
    m_dcdc_error_word_3 = new QVariantSignal_dcdc_error_word_3(modbusQtMessages::instance().map[0x7565], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "dcdc_error_word_3", "");
    m_fc_dcdc_current = new QVariantSignal_fc_dcdc_current(modbusQtMessages::instance().map[0x9c44], QVariant::fromValue(32767), QVariant::fromValue(-32768), 0.01, "A", "fc_dcdc_current", "");
    m_fc_power_max = new QVariantSignal_fc_power_max(modbusQtMessages::instance().map[0x7600], QVariant::fromValue(65535), QVariant::fromValue(0), 10, "W", "fc_power_max", "");
    m_dc_bus_voltage = new QVariantSignal_dc_bus_voltage(modbusQtMessages::instance().map[0x7539], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "V", "dc_bus_voltage", "");
    m_dcdc_warning_word_1 = new QVariantSignal_dcdc_warning_word_1(modbusQtMessages::instance().map[0x756d], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "A", "dcdc_warning_word_1", "");
    m_fcstack_voltage = new QVariantSignal_fcstack_voltage(modbusQtMessages::instance().map[0x7537], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "V", "fcstack_voltage", "");
    m_dcdc_warning_word_3 = new QVariantSignal_dcdc_warning_word_3(modbusQtMessages::instance().map[0x756f], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "A", "dcdc_warning_word_3", "");
    m_status_freeze_protection = new QVariantSignal_status_freeze_protection(modbusQtMessages::instance().map[0x75f9], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "status_freeze_protection", "");
    m_dcdc_pwr_unit_temperature = new QVariantSignal_dcdc_pwr_unit_temperature(modbusQtMessages::instance().map[0x7533], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "°C", "dcdc_pwr_unit_temperature", "");
    m_fcstack_current = new QVariantSignal_fcstack_current(modbusQtMessages::instance().map[0x7538], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "A", "fcstack_current", "");
    m_system_off_request = new QVariantSignal_system_off_request(modbusQtMessages::instance().map[0x9d0c], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "system_off_request", "");
    m_dcdc_status = new QVariantSignal_dcdc_status(modbusQtMessages::instance().map[0x7532], QVariant::fromValue(255), QVariant::fromValue(0), 1, "", "dcdc_status", "");
    m_pos_mix_valve2 = new QVariantSignal_pos_mix_valve2(modbusQtMessages::instance().map[0x75fa], QVariant::fromValue(255), QVariant::fromValue(0), 1, "%", "pos_mix_valve2", "");
    m_dcdc_error_word_1 = new QVariantSignal_dcdc_error_word_1(modbusQtMessages::instance().map[0x7563], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "dcdc_error_word_1", "");
    m_tcm_hs_pri_out2 = new QVariantSignal_tcm_hs_pri_out2(modbusQtMessages::instance().map[0x75fb], QVariant::fromValue(32767), QVariant::fromValue(-32768), 0.1, "°C", "tcm_hs_pri_out2", "");
    m_fc_event_code2 = new QVariantSignal_fc_event_code2(modbusQtMessages::instance().map[0x762b], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "fc_event_code2", "");
    m_dcdc_reset2 = new QVariantSignal_dcdc_reset2(modbusQtMessages::instance().map[0x9c47], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "dcdc_reset2", "");
    m_fcstack_status = new QVariantSignal_fcstack_status(modbusQtMessages::instance().map[0x7531], QVariant::fromValue(255), QVariant::fromValue(0), 1, "", "fcstack_status", "");
    m_fast_shutdown_request = new QVariantSignal_fast_shutdown_request(modbusQtMessages::instance().map[0x9d0c], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "fast_shutdown_request", "");
    m_tcm_hs_sec_in_sp2 = new QVariantSignal_tcm_hs_sec_in_sp2(modbusQtMessages::instance().map[0x75fc], QVariant::fromValue(32767), QVariant::fromValue(-32768), 0.1, "°C", "tcm_hs_sec_in_sp2", "");
    m_dc_bus_current = new QVariantSignal_dc_bus_current(modbusQtMessages::instance().map[0x753a], QVariant::fromValue(65535), QVariant::fromValue(0), 0.01, "A", "dc_bus_current", "");
    m_fc_power_sp = new QVariantSignal_fc_power_sp(modbusQtMessages::instance().map[0x7605], QVariant::fromValue(65535), QVariant::fromValue(0), 10, "W", "fc_power_sp", "");
    m_estimated_time_for_shutdown = new QVariantSignal_estimated_time_for_shutdown(modbusQtMessages::instance().map[0x7604], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "sec", "estimated_time_for_shutdown", "");
    m_fc_power_opt = new QVariantSignal_fc_power_opt(modbusQtMessages::instance().map[0x75ff], QVariant::fromValue(65535), QVariant::fromValue(0), 10, "W", "fc_power_opt", "");
    m_dcdc_error_word_2 = new QVariantSignal_dcdc_error_word_2(modbusQtMessages::instance().map[0x7564], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "dcdc_error_word_2", "");
    m_fc_dcdc_running = new QVariantSignal_fc_dcdc_running(modbusQtMessages::instance().map[0x9c41], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "fc_dcdc_running", "");
    m_mute_h2_sens_exhaust2 = new QVariantSignal_mute_h2_sens_exhaust2(modbusQtMessages::instance().map[0x75f9], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "mute_h2_sens_exhaust2", "");
    m_power_current_mode = new QVariantSignal_power_current_mode(modbusQtMessages::instance().map[0x9d09], QVariant::fromValue(255), QVariant::fromValue(0), 1, "", "power_current_mode", "");
    m_freeze_protection_request = new QVariantSignal_freeze_protection_request(modbusQtMessages::instance().map[0x9d0c], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "freeze_protection_request", "");
    m_fc_dcdc_power = new QVariantSignal_fc_dcdc_power(modbusQtMessages::instance().map[0x9c45], QVariant::fromValue(32767), QVariant::fromValue(-32768), 0.01, "kW", "fc_dcdc_power", "");
    m_fc_power_act = new QVariantSignal_fc_power_act(modbusQtMessages::instance().map[0x75fd], QVariant::fromValue(65535), QVariant::fromValue(0), 10, "W", "fc_power_act", "");
    m_dcdc_voltage = new QVariantSignal_dcdc_voltage(modbusQtMessages::instance().map[0x9c43], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "V", "dcdc_voltage", "");
    m_fc_power_min = new QVariantSignal_fc_power_min(modbusQtMessages::instance().map[0x7602], QVariant::fromValue(65535), QVariant::fromValue(0), 10, "W", "fc_power_min", "");
    m_dcdc_status_word_1 = new QVariantSignal_dcdc_status_word_1(modbusQtMessages::instance().map[0x7595], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "dcdc_status_word_1", "");
    m_fc_power_max_state = new QVariantSignal_fc_power_max_state(modbusQtMessages::instance().map[0x7601], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "W", "fc_power_max_state", "");
    m_dcdc_max_available_fc_current = new QVariantSignal_dcdc_max_available_fc_current(modbusQtMessages::instance().map[0x7535], QVariant::fromValue(65535), QVariant::fromValue(0), 0.1, "A", "dcdc_max_available_fc_current", "");
    m_fc_power_peripheral = new QVariantSignal_fc_power_peripheral(modbusQtMessages::instance().map[0x75fe], QVariant::fromValue(65535), QVariant::fromValue(0), 10, "W", "fc_power_peripheral", "");
    m_fc_dcdc_power_limitation = new QVariantSignal_fc_dcdc_power_limitation(modbusQtMessages::instance().map[0x9c46], QVariant::fromValue(32767), QVariant::fromValue(-32768), 0.01, "kW", "fc_dcdc_power_limitation", "");
    m_fc_extended_info1 = new QVariantSignal_fc_extended_info1(modbusQtMessages::instance().map[0x762d], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "fc_extended_info1", "");
    m_fc_dcdc_failure = new QVariantSignal_fc_dcdc_failure(modbusQtMessages::instance().map[0x9c41], QVariant::fromValue(1), QVariant::fromValue(0), 1, "", "fc_dcdc_failure", "");
    m_fc_event_code1 = new QVariantSignal_fc_event_code1(modbusQtMessages::instance().map[0x762b], QVariant::fromValue(65535), QVariant::fromValue(0), 1, "", "fc_event_code1", "");
    m_dcdc_max_available_power = new QVariantSignal_dcdc_max_available_power(modbusQtMessages::instance().map[0x7536], QVariant::fromValue(65535), QVariant::fromValue(0), 0.01, "kW", "dcdc_max_available_power", "");
}

void QVariantSignal_dcdc_warning_word_2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_warning_word_2*>(parent)->store.dcdc_warning_word_2 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_warning_word_2*>(parent)->store.dcdc_warning_word_2 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_power_current_reference::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_power_current_reference*>(parent)->store.power_current_reference - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_power_current_reference*>(parent)->store.power_current_reference = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_estimated_time_to_power::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_estimated_time_to_power*>(parent)->store.estimated_time_to_power - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_estimated_time_to_power*>(parent)->store.estimated_time_to_power = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_max_available_current::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_max_available_current*>(parent)->store.dcdc_max_available_current - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_max_available_current*>(parent)->store.dcdc_max_available_current = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_power_current_min_handling::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_power_current_min_handling*>(parent)->store.power_current_min_handling - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_power_current_min_handling*>(parent)->store.power_current_min_handling = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_extended_info2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_extended_info*>(parent)->store.fc_extended_info2 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_extended_info*>(parent)->store.fc_extended_info2 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_error_word_3::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_30053*>(parent)->store.dcdc_error_word_3 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_30053*>(parent)->store.dcdc_error_word_3 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_dcdc_current::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_dcdc_current*>(parent)->store.fc_dcdc_current - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_dcdc_current*>(parent)->store.fc_dcdc_current = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_max::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_max*>(parent)->store.fc_power_max - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_max*>(parent)->store.fc_power_max = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dc_bus_voltage::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dc_bus_voltage*>(parent)->store.dc_bus_voltage - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dc_bus_voltage*>(parent)->store.dc_bus_voltage = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_warning_word_1::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_warning_word_1*>(parent)->store.dcdc_warning_word_1 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_warning_word_1*>(parent)->store.dcdc_warning_word_1 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fcstack_voltage::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fcstack_voltage*>(parent)->store.fcstack_voltage - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fcstack_voltage*>(parent)->store.fcstack_voltage = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_warning_word_3::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_warning_word_3*>(parent)->store.dcdc_warning_word_3 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_warning_word_3*>(parent)->store.dcdc_warning_word_3 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_status_freeze_protection::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_30201*>(parent)->store.status_freeze_protection - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_30201*>(parent)->store.status_freeze_protection = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_pwr_unit_temperature::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_pwr_unit_temperature*>(parent)->store.dcdc_pwr_unit_temperature - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_pwr_unit_temperature*>(parent)->store.dcdc_pwr_unit_temperature = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fcstack_current::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fcstack_current*>(parent)->store.fcstack_current - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fcstack_current*>(parent)->store.fcstack_current = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_system_off_request::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_40204*>(parent)->store.system_off_request - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_40204*>(parent)->store.system_off_request = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_status::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_status*>(parent)->store.dcdc_status - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_status*>(parent)->store.dcdc_status = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_pos_mix_valve2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_pos_mix_valve*>(parent)->store.pos_mix_valve2 - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_pos_mix_valve*>(parent)->store.pos_mix_valve2 = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_error_word_1::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_30051*>(parent)->store.dcdc_error_word_1 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_30051*>(parent)->store.dcdc_error_word_1 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_tcm_hs_pri_out2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_tcm_hs_pri_out*>(parent)->store.tcm_hs_pri_out2 - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_tcm_hs_pri_out*>(parent)->store.tcm_hs_pri_out2 = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_event_code2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_event_code*>(parent)->store.fc_event_code2 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_event_code*>(parent)->store.fc_event_code2 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_reset2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_command*>(parent)->store.dcdc_reset2 - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_command*>(parent)->store.dcdc_reset2 = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fcstack_status::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fcstack_status*>(parent)->store.fcstack_status - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fcstack_status*>(parent)->store.fcstack_status = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fast_shutdown_request::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_40204*>(parent)->store.fast_shutdown_request - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_40204*>(parent)->store.fast_shutdown_request = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_tcm_hs_sec_in_sp2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_tcm_hs_sec_in_sp*>(parent)->store.tcm_hs_sec_in_sp2 - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_tcm_hs_sec_in_sp*>(parent)->store.tcm_hs_sec_in_sp2 = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dc_bus_current::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dc_bus_current*>(parent)->store.dc_bus_current - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dc_bus_current*>(parent)->store.dc_bus_current = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_sp::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_sp*>(parent)->store.fc_power_sp - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_sp*>(parent)->store.fc_power_sp = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_estimated_time_for_shutdown::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_estimated_time_for_shutdown*>(parent)->store.estimated_time_for_shutdown - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_estimated_time_for_shutdown*>(parent)->store.estimated_time_for_shutdown = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_opt::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_opt*>(parent)->store.fc_power_opt - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_opt*>(parent)->store.fc_power_opt = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_error_word_2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_30052*>(parent)->store.dcdc_error_word_2 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_30052*>(parent)->store.dcdc_error_word_2 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_dcdc_running::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_dcdc_status*>(parent)->store.fc_dcdc_running - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_dcdc_status*>(parent)->store.fc_dcdc_running = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_mute_h2_sens_exhaust2::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_30201*>(parent)->store.mute_h2_sens_exhaust2 - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_30201*>(parent)->store.mute_h2_sens_exhaust2 = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_power_current_mode::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_power_current_mode*>(parent)->store.power_current_mode - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_power_current_mode*>(parent)->store.power_current_mode = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_freeze_protection_request::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_40204*>(parent)->store.freeze_protection_request - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_40204*>(parent)->store.freeze_protection_request = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_dcdc_power::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_dcdc_power*>(parent)->store.fc_dcdc_power - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_dcdc_power*>(parent)->store.fc_dcdc_power = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_act::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_act*>(parent)->store.fc_power_act - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_act*>(parent)->store.fc_power_act = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_voltage::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_voltage*>(parent)->store.dcdc_voltage - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_voltage*>(parent)->store.dcdc_voltage = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_min::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_min*>(parent)->store.fc_power_min - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_min*>(parent)->store.fc_power_min = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_status_word_1::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_msg_30101*>(parent)->store.dcdc_status_word_1 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_msg_30101*>(parent)->store.dcdc_status_word_1 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_max_state::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_max_state*>(parent)->store.fc_power_max_state - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_max_state*>(parent)->store.fc_power_max_state = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_max_available_fc_current::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_max_available_fc_current*>(parent)->store.dcdc_max_available_fc_current - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_max_available_fc_current*>(parent)->store.dcdc_max_available_fc_current = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_power_peripheral::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_power_peripheral*>(parent)->store.fc_power_peripheral - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_power_peripheral*>(parent)->store.fc_power_peripheral = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_dcdc_power_limitation::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_dcdc_power_limitation*>(parent)->store.fc_dcdc_power_limitation - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_dcdc_power_limitation*>(parent)->store.fc_dcdc_power_limitation = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_extended_info1::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_extended_info*>(parent)->store.fc_extended_info1 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_extended_info*>(parent)->store.fc_extended_info1 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_dcdc_failure::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_dcdc_status*>(parent)->store.fc_dcdc_failure - static_cast<uint8_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_dcdc_status*>(parent)->store.fc_dcdc_failure = static_cast<uint8_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_fc_event_code1::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_fc_event_code*>(parent)->store.fc_event_code1 - static_cast<uint16_t>(x.toUInt())) > 1.0e-05;
    static_cast<modbusQtMessage_fc_event_code*>(parent)->store.fc_event_code1 = static_cast<uint16_t>(x.toUInt());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}

void QVariantSignal_dcdc_max_available_power::send(QVariant x, int option) {
    bool diff = qAbs(static_cast<modbusQtMessage_dcdc_max_available_power*>(parent)->store.dcdc_max_available_power - static_cast<float>(x.toFloat())) > 1.0e-05;
    static_cast<modbusQtMessage_dcdc_max_available_power*>(parent)->store.dcdc_max_available_power = static_cast<float>(x.toFloat());
    m_val = x;
    
    if ((option!=1/*silent*/) && (diff || (option==0) || (option==3))) { // option=2 implements "smart_val"
        emit this->changed(QDateTime::currentDateTimeUtc());
        parent->send_frame();
    }
}



void modbusQtMessage_dc_bus_current::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dc_bus_current_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_max_state::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_max_state_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_sp::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_sp_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_max_available_power::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_max_available_power_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_msg_40204::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_msg_40204_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_msg_30201::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_msg_30201_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_min::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_min_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_pos_mix_valve::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_pos_mix_valve_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_dcdc_status::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_dcdc_status_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_warning_word_3::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_warning_word_3_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fcstack_voltage::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fcstack_voltage_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_msg_30052::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_msg_30052_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_pwr_unit_temperature::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_pwr_unit_temperature_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_voltage::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_voltage_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_extended_info::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[4];
    modbus_fc_extended_info_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_msg_30051::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_msg_30051_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_estimated_time_to_power::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_estimated_time_to_power_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_command::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_command_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_estimated_time_for_shutdown::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_estimated_time_for_shutdown_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dc_bus_voltage::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dc_bus_voltage_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_tcm_hs_sec_in_sp::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_tcm_hs_sec_in_sp_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_power_current_mode::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_power_current_mode_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_event_code::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[4];
    modbus_fc_event_code_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_act::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_act_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_max_available_fc_current::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_max_available_fc_current_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_power_current_min_handling::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_power_current_min_handling_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_max_available_current::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_max_available_current_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_warning_word_1::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_warning_word_1_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_status::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_status_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_tcm_hs_pri_out::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_tcm_hs_pri_out_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_dcdc_warning_word_2::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_dcdc_warning_word_2_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_peripheral::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_peripheral_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_msg_30053::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_msg_30053_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fcstack_status::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fcstack_status_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_opt::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_opt_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_dcdc_power_limitation::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_dcdc_power_limitation_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_power_current_reference::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_power_current_reference_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_power_max::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_power_max_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_msg_30101::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_msg_30101_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_dcdc_power::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_dcdc_power_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fc_dcdc_current::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fc_dcdc_current_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage_fcstack_current::send_frame() { // QByteArray payload, bool is_extended
    // (void)is_extended; // avoid C4100 warning
    
    uint8_t dst_p[2];
    modbus_fcstack_current_pack(dst_p, &store);
    QByteArray payload = QByteArray(reinterpret_cast<char*>(dst_p), m_length);

    QModbusDataUnit::RegisterType registerType;
    uint startAddress =m_frameId; // oh yes address is the frame id!

    if (startAddress < 10000) {
        registerType = QModbusDataUnit::Coils;
        startAddress -= 1;
    } else if (startAddress < 20000) {
        registerType = QModbusDataUnit::DiscreteInputs;
        startAddress -= 10001;
    } else if (startAddress < 30000) {
        qCritical() << "startaddress not managed: " << startAddress;
        return;
    } else if (startAddress < 40000) {
        registerType = QModbusDataUnit::InputRegisters;
        startAddress -= 30001;
    } else if (startAddress < 50000) {
        registerType = QModbusDataUnit::HoldingRegisters;
        startAddress -= 40001;
    } else {
        qCritical() << "startaddress too big: " << startAddress;
        return;
    }

    QModbusDataUnit unit = QModbusDataUnit(registerType, startAddress, (payload.size() + 1)/2);
    quint16 value;
    for (int i=0; i<payload.size(); i+=2) {
        value = *(quint16*)(payload.constData() + i);
        unit.setValue(i/2, value);
    }
    qCDebug(rgm_cantools_modbus) << "Emit send frame (modbus) => [" << unit.startAddress() << "] reg" << unit.registerType() << ":" << unit.values();
    emit modbusQtMessages::instance().sendFrame(unit, m_stationAddress);
}
        

void modbusQtMessage::update() {
    emit modbusQtMessages::instance().update(m_stationAddress, m_frameId, (m_length+1)/2);
}


void modbus_registers_insertion(QModbusDataUnitMap &reg) {
    reg.insert(QModbusDataUnit::HoldingRegisters, {QModbusDataUnit::HoldingRegisters, 0, 204});
    reg.insert(QModbusDataUnit::InputRegisters, {QModbusDataUnit::InputRegisters, 0, 254});
}

void modbusQtMessages::can_receive_frame_callback(const QModbusDataUnit &frame) {
    modbusQtMessage *msg;
    uint offset = 0;
    switch(frame.registerType()) {
    case QModbusDataUnit::Invalid: offset = 0; break;
    case QModbusDataUnit::Coils: offset = 1; break;
    case QModbusDataUnit::DiscreteInputs: offset = 10001; break;
    case QModbusDataUnit::InputRegisters: offset = 30001; break;
    case QModbusDataUnit::HoldingRegisters: offset = 40001; break;
    }
    msg = modbusQtMessages::instance().map.value(offset + static_cast<uint>(frame.startAddress()), nullptr);
    if (msg) msg->received(frame);
}

